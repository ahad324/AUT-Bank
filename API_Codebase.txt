g:/Ahad/Python/AUT Bank/app/main.py
<DOCUMENT>
import os
import uvicorn
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import HTTPException as FastAPIHTTPException
from fastapi.middleware.gzip import GZipMiddleware

from app.core.rate_limiter import limiter, custom_rate_limit_handler
from slowapi.errors import RateLimitExceeded
from app.core.exceptions import CustomHTTPException
from app.core.schemas import BaseResponse
from app.routes import admins, users, atm, rbac, websocket as websocket_routes
from app.core.database import get_db

app = FastAPI(
    title="AUT Banking System",
    version="1.0.0",
    default_response_model=BaseResponse,
    description="Official API documentation for AUT Bank's backend services",
    responses={
        400: {"model": BaseResponse},
        401: {"model": BaseResponse},
        403: {"model": BaseResponse},
        404: {"model": BaseResponse},
        422: {"model": BaseResponse},
        429: {"model": BaseResponse},
        500: {"model": BaseResponse},
    },
)

# <========== Gzip Middleware ==========>
app.add_middleware(GZipMiddleware, minimum_size=1000)  # Compress responses > 1KB

# <========== CORS Configuration ==========>
allowed_origins = os.getenv("ALLOWED_ORIGINS", "*").split(",")
app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# <========== Rate limiting middleware ==========>
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, custom_rate_limit_handler)


# <========== Storing DB session in app state for use in rate limiter ==========>
@app.middleware("http")
async def add_db_to_request(request: Request, call_next):
    db = next(get_db())  # Get DB session
    request.state.db = db
    try:
        response = await call_next(request)
        db.commit()  # Commit only if successful
        return response
    except Exception as e:
        db.rollback()  # Rollback on any error
        raise e  # Re-raise for FastAPI to handle
    finally:
        db.close()  # Always close the session


# <========== API routes ==========>
app.include_router(
    users.router,
    prefix="/api/v1/users",
    tags=["User"],
    responses={404: {"description": "Not found"}},
)
app.include_router(
    admins.router,
    prefix="/api/v1/admins",
    tags=["Admin"],
    responses={404: {"description": "Not found"}},
)
app.include_router(
    atm.router,
    prefix="/api/v1/atm",
    tags=["ATM"],
    responses={404: {"description": "Not found"}},
)
app.include_router(
    rbac.router,
    prefix="/api/v1/rbac",
    tags=["RBAC"],
    responses={404: {"description": "Not found"}},
)
app.include_router(
    websocket_routes.router,
    prefix="/api/v1",
    tags=["WebSocket"],
    responses={404: {"description": "Not found"}},
)


# <========== Exception Handlers ==========>
# Custom exception handler
@app.exception_handler(CustomHTTPException)
async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": exc.detail.get("success", False),
            "message": exc.detail.get("message", "An error occurred"),
            "data": exc.detail.get("data", {}),
            "status_code": exc.status_code,
        },
    )


# Generic HTTPException handler for rate limiting and other cases
@app.exception_handler(FastAPIHTTPException)
async def http_exception_handler(request: Request, exc: FastAPIHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "message": (
                exc.detail.get("message")
                if isinstance(exc.detail, dict)
                else str(exc.detail)
            ),
            "data": exc.detail.get("data") if isinstance(exc.detail, dict) else None,
            "status_code": exc.status_code,
        },
        headers=exc.headers,
    )


# <========== System Endpoints ==========>
# Health check endpoint with rate limit
@app.get("/health", tags=["System"], response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_PUBLIC", "1000/hour"))
async def health_check(request: Request):
    return {
        "success": True,
        "message": "System is healthy",
        "status_code": status.HTTP_200_OK,
    }


# Root endpoint with rate limit
@app.get("/", response_model=BaseResponse, tags=["System"])
@limiter.limit(os.getenv("RATE_LIMIT_PUBLIC", "1000/hour"))
async def root(request: Request):
    return {
        "success": True,
        "message": "Welcome to AUT Bank API. Access /docs or /redoc for documentation.",
        "data": {
            "version": app.version,
            "documentation": {"swagger": "/docs", "redoc": "/redoc"},
        },
        "status_code": status.HTTP_200_OK,
    }


# <========== Application Startup ==========>
if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    workers = int(os.getenv("WORKERS", 1))  # Default to 1 worker for dev
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=port,
        workers=workers,
        reload=os.getenv("RELOAD", "false").lower() == "true",  # Auto-reload in dev
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/admin_controller.py
<DOCUMENT>
from io import StringIO
import csv
from fastapi.responses import StreamingResponse
from typing import Optional
from fastapi import BackgroundTasks, status
from sqlalchemy import asc, case, desc, func, or_
from sqlalchemy.orm import Session
from passlib.context import CryptContext
from datetime import date, datetime, timezone

# Schemas
from app import schemas
from app.models.loan import Loan, LoanType
from app.models.rbac import Permission, Role, RolePermission
from app.models.user import User
from app.schemas.admin_schema import (
    AdminCreate,
    AdminLogin,
    AdminOrder,
    RoleData,
    PermissionData,
    AdminResponseData,
    AdminLoginResponseData,
    AdminSortBy,
)
from app.schemas.admin_schema import AdminUpdate, AdminPasswordUpdate

# Models
from app.models.admin import Admin
from app.models.deposit import Deposit
from app.models.transfer import Transfer
from app.models.withdrawal import Withdrawal

# Core
from app.core.utils import hash_password, check_unique_field
from app.core.exceptions import CustomHTTPException, DatabaseError
from app.core.schemas import PaginatedResponse
from app.core.auth import create_access_token, create_refresh_token
from app.core.responses import success_response
from app.schemas.card_schema import CardResponse
from app.schemas.deposit_schema import DepositResponse
from app.schemas.loan_schema import LoanResponse
from app.schemas.transfer_schema import TransferResponse
from app.schemas.user_schema import Order, SortBy, UserResponseData, UserUpdate
from app.schemas.withdrawal_schema import WithdrawalResponse

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def register_admin(admin: AdminCreate, db: Session):
    check_unique_field(db, Admin, "Email", admin.Email)
    check_unique_field(db, Admin, "Username", admin.Username)

    new_admin = Admin(
        Username=admin.Username,
        Email=admin.Email,
        Password=hash_password(admin.Password),
        RoleID=admin.RoleID,
    )

    try:
        db.add(new_admin)
        db.commit()
        db.refresh(new_admin)
        return success_response(
            message="Admin registered successfully",
            data=AdminResponseData.model_validate(new_admin).model_dump(),
            status_code=status.HTTP_201_CREATED,
        )
    except Exception as e:
        db.rollback()
        raise DatabaseError(f"Database error: {str(e)}")


def login_admin(admin: AdminLogin, db: Session):
    admin_db = db.query(Admin).filter(Admin.Email == admin.Email).first()
    if not admin_db or not pwd_context.verify(admin.Password, admin_db.Password):
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            message="Invalid email or password",
        )

    # Fetch role details
    role = db.query(Role).filter(Role.RoleID == admin_db.RoleID).first()
    if not role:
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Role not found for this admin",
        )

    # Fetch permissions for the role
    permissions = (
        db.query(Permission)
        .join(RolePermission, RolePermission.PermissionID == Permission.PermissionID)
        .filter(RolePermission.RoleID == admin_db.RoleID)
        .all()
    )

    admin_db.LastLogin = datetime.now(timezone.utc)
    db.commit()

    access_token = create_access_token(
        data={"sub": str(admin_db.AdminID), "role_id": admin_db.RoleID}
    )
    refresh_token = create_refresh_token(
        data={"sub": str(admin_db.AdminID), "role_id": admin_db.RoleID}
    )
    # Prepare role and permissions data
    role_data = RoleData.model_validate(role)
    permissions_data = [PermissionData.model_validate(perm) for perm in permissions]

    return success_response(
        message="Login successful",
        data=AdminLoginResponseData(
            AdminID=admin_db.AdminID,
            Username=admin_db.Username,
            Email=admin_db.Email,
            Role=role_data,
            Permissions=permissions_data,
            LastLogin=admin_db.LastLogin.isoformat() if admin_db.LastLogin else None,
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
        ).model_dump(),
    )


def get_all_admins(
    db: Session,
    current_admin_id: int,  # Use current_admin.AdminID
    page: int = 1,
    per_page: int = 10,
    username: Optional[str] = None,
    email: Optional[str] = None,
    role: Optional[str] = None,
    sort_by: Optional[AdminSortBy] = None,
    order: Optional[AdminOrder] = None,
):
    query = db.query(Admin)

    # Filtering
    if username:
        query = query.filter(Admin.Username.ilike(f"%{username}%"))
    if email:
        query = query.filter(Admin.Email.ilike(f"%{email}%"))
    if role:
        query = query.filter(Admin.Role == role)

    # Sorting
    sort_column = {
        AdminSortBy.admin_id: Admin.AdminID,
        AdminSortBy.username: Admin.Username,
        AdminSortBy.email: Admin.Email,
        AdminSortBy.role: Admin.RoleID,
        AdminSortBy.created_at: Admin.CreatedAt,
        AdminSortBy.last_login: Admin.LastLogin,
    }.get(
        sort_by, Admin.AdminID
    )  # Default to AdminID
    query = query.order_by(
        asc(sort_column) if order == AdminOrder.asc else desc(sort_column)
    )

    # Pagination
    total_admins = query.count()
    admins = query.offset((page - 1) * per_page).limit(per_page).all()
    admin_data = [
        AdminResponseData.model_validate(admin).model_dump() for admin in admins
    ]

    return PaginatedResponse(
        success=True,
        message="Admins retrieved successfully",
        data={"admins": admin_data},
        page=page,
        per_page=per_page,
        total_items=total_admins,
        total_pages=(total_admins + per_page - 1) // per_page,
    )


def toggle_user_active_status(user_id: int, current_admin_id: int, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()

    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    user.IsActive = not user.IsActive
    if user.IsActive:  # If activating, set the approving admin
        user.ApprovedByAdminID = current_admin_id
    else:  # If deactivating, clear the approving admin
        user.ApprovedByAdminID = None

    db.commit()
    return success_response(
        message=f"User status updated successfully. New status: {'Active' if user.IsActive else 'Inactive'}",
        data={
            "UserID": user.UserID,
            "IsActive": user.IsActive,
            "ApprovedByAdminID": user.ApprovedByAdminID,
        },
    )


def get_all_users(
    page: int,
    per_page: int,
    username: Optional[str] = None,
    email: Optional[str] = None,
    isactive: Optional[bool] = None,
    account_type: Optional[str] = None,
    balance_min: Optional[float] = None,
    balance_max: Optional[float] = None,
    sort_by: Optional[SortBy] = None,
    order: Optional[Order] = None,
    db: Session = None,
):
    query = db.query(User)

    # Apply filters
    if username:
        query = query.filter(User.Username.ilike(f"%{username}%"))
    if email:
        query = query.filter(User.Email.ilike(f"%{email}%"))
    if account_type:
        query = query.filter(User.AccountType == account_type)
    if balance_min is not None:
        query = query.filter(User.Balance >= balance_min)
    if balance_max is not None:
        query = query.filter(User.Balance <= balance_max)
    if isactive is not None:
        query = query.filter(User.IsActive == isactive)

    # Apply sorting
    sort_field = {
        SortBy.user_id: User.UserID,
        SortBy.username: User.Username,
        SortBy.email: User.Email,
        SortBy.balance: User.Balance,
        SortBy.created_at: User.CreatedAt,
        SortBy.last_login: User.LastLogin,
    }.get(
        sort_by, User.UserID
    )  # Default to UserID if sort_by is invalid

    sort_order = desc if order == Order.desc else asc
    query = query.order_by(sort_order(sort_field))

    # Pagination
    offset = (page - 1) * per_page
    users = query.offset(offset).limit(per_page).all()
    total_items = query.count()
    total_pages = (total_items + per_page - 1) // per_page

    return PaginatedResponse(
        success=True,
        message="Users retrieved successfully",
        data={
            "users": [UserResponseData.model_validate(u).model_dump() for u in users]
        },
        page=page,
        per_page=per_page,
        total_items=total_items,
        total_pages=total_pages,
    ).model_dump()


def update_user(user_id: int, user_update: UserUpdate, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    # Check for unique constraints
    if user_update.Username and user_update.Username != user.Username:
        if db.query(User).filter(User.Username == user_update.Username).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Username already exists",
            )
    if user_update.Email and user_update.Email != user.Email:
        if db.query(User).filter(User.Email == user_update.Email).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Email already exists"
            )

    # Handle password update if provided
    update_data = user_update.model_dump(exclude_unset=True)
    if "Password" in update_data:
        user.Password = pwd_context.hash(
            update_data.pop("Password")
        )  # Hash and remove from update_data

    # Apply updates (including IsActive for admins)
    for key, value in update_data.items():
        setattr(user, key, value)

    try:
        db.commit()
        db.refresh(user)
        return success_response(
            message="User updated successfully",
            data=UserResponseData.model_validate(user).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to update user",
            details={"error": str(e)},
        )


def delete_user(user_id: int, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    # Check for active loans
    active_loans = (
        db.query(Loan)
        .filter(Loan.UserID == user_id, Loan.LoanStatus.in_(["Pending", "Approved"]))
        .count()
    )
    if active_loans > 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message=f"Cannot delete user with {active_loans} active loan(s)",
        )

    # Optionally check for non-zero balance or active transactions
    if user.Balance != 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Cannot delete user with non-zero balance",
        )

    try:
        db.delete(user)
        db.commit()
        return success_response(
            message="User deleted successfully", data={"UserID": user_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to delete user",
            details={"error": str(e)},
        )


def get_analytics_summary(db: Session):
    # Total Users
    total_users = db.query(User).count()
    active_users = db.query(User).filter(User.IsActive == True).count()
    inactive_users = total_users - active_users

    # Total Transaction Volume
    deposit_total = (
        db.query(func.sum(Deposit.Amount))
        .filter(Deposit.Status == "Completed")
        .scalar()
        or 0
    )
    transfer_total = (
        db.query(func.sum(Transfer.Amount))
        .filter(Transfer.Status == "Completed")
        .scalar()
        or 0
    )
    withdrawal_total = (
        db.query(func.sum(Withdrawal.Amount))
        .filter(Withdrawal.Status == "Completed")
        .scalar()
        or 0
    )
    total_transaction_volume = float(deposit_total + transfer_total + withdrawal_total)

    # Total Loan Amounts
    total_loan_amount = (
        db.query(func.sum(Loan.LoanAmount))
        .filter(Loan.LoanStatus == "Approved")
        .scalar()
        or 0
    )
    total_loan_count = db.query(Loan).filter(Loan.LoanStatus == "Approved").count()

    # Pending Loans
    pending_loan_count = db.query(Loan).filter(Loan.LoanStatus == "Pending").count()
    pending_loan_amount = (
        db.query(func.sum(Loan.LoanAmount))
        .filter(Loan.LoanStatus == "Pending")
        .scalar()
        or 0
    )

    # Repaid Loans
    repaid_loan_count = db.query(Loan).filter(Loan.LoanStatus == "Repaid").count()

    # Average User Balance
    avg_user_balance = db.query(func.avg(User.Balance)).scalar() or 0

    return success_response(
        message="Analytics summary retrieved successfully",
        data={
            "users": {
                "total": total_users,
                "active": active_users,
                "inactive": inactive_users,
            },
            "transactions": {
                "total_volume": total_transaction_volume,
                "deposits": float(deposit_total),
                "transfers": float(transfer_total),
                "withdrawals": float(withdrawal_total),
            },
            "loans": {
                "total_approved_amount": float(total_loan_amount),
                "total_approved_count": total_loan_count,
                "pending_count": pending_loan_count,
                "pending_amount": float(pending_loan_amount),
                "repaid_count": repaid_loan_count,
            },
            "average_user_balance": float(avg_user_balance),
        },
    )


def get_current_admin(admin_id: int, db: Session):
    admin = db.query(Admin).filter(Admin.AdminID == admin_id).first()
    if not admin:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Admin not found"
        )
    role = db.query(Role).filter(Role.RoleID == admin.RoleID).first()
    permissions = (
        db.query(Permission)
        .join(RolePermission, RolePermission.PermissionID == Permission.PermissionID)
        .filter(RolePermission.RoleID == admin.RoleID)
        .all()
    )
    return success_response(
        message="Admin details retrieved successfully",
        data=AdminLoginResponseData(
            AdminID=admin.AdminID,
            Username=admin.Username,
            Email=admin.Email,
            Role=RoleData.model_validate(role),
            Permissions=[PermissionData.model_validate(perm) for perm in permissions],
            LastLogin=admin.LastLogin.isoformat() if admin.LastLogin else None,
            access_token="",
            refresh_token="",
            token_type="bearer",
        ).model_dump(exclude={"access_token", "refresh_token"}),
    )


def update_current_admin(admin_id: int, admin_update: AdminUpdate, db: Session):
    admin = db.query(Admin).filter(Admin.AdminID == admin_id).first()
    if not admin:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Admin not found"
        )
    update_data = admin_update.model_dump(exclude_unset=True)
    if "Username" in update_data and update_data["Username"] != admin.Username:
        if db.query(Admin).filter(Admin.Username == update_data["Username"]).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Username already exists",
            )
    if "Email" in update_data and update_data["Email"] != admin.Email:
        if db.query(Admin).filter(Admin.Email == update_data["Email"]).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Email already exists"
            )
    for key, value in update_data.items():
        setattr(admin, key, value)
    try:
        db.commit()
        db.refresh(admin)
        db.commit()
        return success_response(
            message="Admin profile updated successfully",
            data=AdminResponseData.model_validate(admin).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to update admin",
            details={"error": str(e)},
        )


def update_admin_password(
    admin_id: int, password_update: AdminPasswordUpdate, db: Session
):
    admin = db.query(Admin).filter(Admin.AdminID == admin_id).first()
    if not admin:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Admin not found"
        )
    if not pwd_context.verify(password_update.CurrentPassword, admin.Password):
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Current password is incorrect",
        )
    admin.Password = pwd_context.hash(password_update.NewPassword)
    try:
        db.commit()
        db.commit()
        return success_response(
            message="Password updated successfully", data={"AdminID": admin_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to update password",
            details={"error": str(e)},
        )


def get_admin_by_id(admin_id: int, db: Session):
    admin = db.query(Admin).filter(Admin.AdminID == admin_id).first()
    if not admin:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Admin not found"
        )
    return success_response(
        message="Admin details retrieved successfully",
        data=AdminResponseData.model_validate(admin).model_dump(),
    )


def delete_admin(admin_id: int, current_admin_id: int, db: Session):
    if admin_id == current_admin_id:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Cannot delete own account"
        )
    admin = db.query(Admin).filter(Admin.AdminID == admin_id).first()
    if not admin:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Admin not found"
        )
    try:
        db.delete(admin)
        db.commit()
        db.commit()
        return success_response(
            message="Admin deleted successfully", data={"AdminID": admin_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to delete admin",
            details={"error": str(e)},
        )


def get_user_by_id(user_id: int, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )
    return success_response(
        message="User details retrieved successfully",
        data=UserResponseData.model_validate(user).model_dump(),
    )


def get_user_deposits(
    user_id: int,
    db: Session,
    page: int = 1,
    per_page: int = 10,
    deposit_status: Optional[str] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    sort_by: Optional[str] = "Timestamp",
    order: Optional[str] = "desc",
):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )
    query = db.query(Deposit).filter(Deposit.UserID == user_id)
    if deposit_status:
        query = query.filter(Deposit.Status == deposit_status)
    if start_date:
        query = query.filter(Deposit.Timestamp >= start_date)
    if end_date:
        query = query.filter(Deposit.Timestamp <= end_date)
    sort_field = getattr(Deposit, sort_by, Deposit.Timestamp)
    query = query.order_by(desc(sort_field) if order == "desc" else asc(sort_field))
    total_deposits = query.count()
    deposits = query.offset((page - 1) * per_page).limit(per_page).all()
    return PaginatedResponse(
        success=True,
        message="Deposits retrieved successfully",
        data={
            "deposits": [
                DepositResponse.model_validate(d).model_dump() for d in deposits
            ]
        },
        page=page,
        per_page=per_page,
        total_items=total_deposits,
        total_pages=(total_deposits + per_page - 1) // per_page,
    )


def get_loan_by_id(loan_id: int, db: Session):
    loan = db.query(Loan).filter(Loan.LoanID == loan_id).first()
    if not loan:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Loan not found"
        )
    loan_type = (
        db.query(LoanType).filter(LoanType.LoanTypeID == loan.LoanTypeID).first()
    )
    return success_response(
        message="Loan details retrieved successfully",
        data=LoanResponse(
            LoanID=loan.LoanID,
            LoanTypeName=loan_type.LoanTypeName,
            LoanAmount=loan.LoanAmount,
            InterestRate=loan.InterestRate,
            LoanDurationMonths=loan.LoanDurationMonths,
            MonthlyInstallment=loan.MonthlyInstallment,
            DueDate=loan.DueDate,
            LoanStatus=loan.LoanStatus,
            CreatedAt=loan.CreatedAt,
        ).model_dump(),
    )


def get_card_by_id(card_id: int, db: Session):
    from app.models.card import Card  # Assuming Card model exists

    card = db.query(Card).filter(Card.CardID == card_id).first()
    if not card:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Card not found"
        )
    return success_response(
        message="Card details retrieved successfully",
        data=CardResponse.model_validate(card).model_dump(),
    )


def unblock_card(card_id: int, db: Session):
    from app.models.card import Card  # Assuming Card model exists

    card = db.query(Card).filter(Card.CardID == card_id).first()
    if not card:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Card not found"
        )
    if card.Status != "Blocked":
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Card is not blocked"
        )
    card.Status = "Active"
    try:
        db.commit()
        return success_response(
            message="Card unblocked successfully", data={"CardID": card_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to unblock card",
            details={"error": str(e)},
        )


def get_transaction_by_id(transaction_id: int, transaction_type: str, db: Session):
    if transaction_type not in ["Deposit", "Transfer", "Withdrawal"]:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Invalid transaction type"
        )
    model = {"Deposit": Deposit, "Transfer": Transfer, "Withdrawal": Withdrawal}[
        transaction_type
    ]
    transaction = (
        db.query(model)
        .filter(model.__table__.c[f"{transaction_type}ID"] == transaction_id)
        .first()
    )
    if not transaction:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            message=f"{transaction_type} not found",
        )
    schema = {
        "Deposit": DepositResponse,
        "Transfer": TransferResponse,
        "Withdrawal": WithdrawalResponse,
    }[transaction_type]
    return success_response(
        message=f"{transaction_type} details retrieved successfully",
        data=schema.model_validate(transaction).model_dump(),
    )


def export_transactions(
    db: Session,
    user_id: Optional[int] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    transaction_status: Optional[str] = None,
    transaction_type: Optional[str] = None,
):
    # Base query (similar to get_all_transactions)
    query = (
        db.query(
            func.coalesce(
                Deposit.DepositID, Transfer.TransferID, Withdrawal.WithdrawalID
            ).label("TransactionID"),
            User.Username.label("Username"),
            func.coalesce(Deposit.Amount, Transfer.Amount, Withdrawal.Amount).label(
                "Amount"
            ),
            func.coalesce(Deposit.Status, Transfer.Status, Withdrawal.Status).label(
                "Status"
            ),
            func.coalesce(
                Deposit.Timestamp, Transfer.Timestamp, Withdrawal.Timestamp
            ).label("Timestamp"),
            case(
                (Deposit.DepositID.isnot(None), "Deposit"),
                (Transfer.TransferID.isnot(None), "Transfer"),
                (Withdrawal.WithdrawalID.isnot(None), "Withdrawal"),
            ).label("TransactionType"),
            Transfer.ReceiverID.label("ReceiverID"),
        )
        .outerjoin(Deposit, Deposit.UserID == User.UserID)
        .outerjoin(Transfer, Transfer.SenderID == User.UserID)
        .outerjoin(Withdrawal, Withdrawal.UserID == User.UserID)
        .filter(
            or_(
                Deposit.DepositID.isnot(None),
                Transfer.TransferID.isnot(None),
                Withdrawal.WithdrawalID.isnot(None),
            )
        )
    )

    # Apply filters
    if user_id:
        query = query.filter(User.UserID == user_id)
    if start_date:
        query = query.filter(
            func.coalesce(Deposit.Timestamp, Transfer.Timestamp, Withdrawal.Timestamp)
            >= start_date
        )
    if end_date:
        query = query.filter(
            func.coalesce(Deposit.Timestamp, Transfer.Timestamp, Withdrawal.Timestamp)
            <= end_date
        )
    if transaction_status:
        if transaction_status not in ["Pending", "Completed", "Failed"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction status value",
            )
        query = query.filter(
            func.coalesce(Deposit.Status, Transfer.Status, Withdrawal.Status)
            == transaction_status
        )
    if transaction_type:
        if transaction_type not in ["Deposit", "Transfer", "Withdrawal"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction type",
            )
        if transaction_type == "Deposit":
            query = query.filter(Deposit.DepositID.isnot(None))
        elif transaction_type == "Transfer":
            query = query.filter(Transfer.TransferID.isnot(None))
        elif transaction_type == "Withdrawal":
            query = query.filter(Withdrawal.WithdrawalID.isnot(None))

    # Execute query
    transactions = query.all()

    if not transactions:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            message="No transactions found for export",
        )

    # Create CSV in memory
    output = StringIO()
    writer = csv.writer(output, quoting=csv.QUOTE_MINIMAL)

    # Write headers
    headers = [
        "TransactionID",
        "Username",
        "Amount",
        "Status",
        "Timestamp",
        "TransactionType",
        "ReceiverUsername",
    ]
    writer.writerow(headers)

    # Fetch receiver usernames for transfers
    receiver_ids = {t.ReceiverID for t in transactions if t.ReceiverID}
    receivers = (
        db.query(User.UserID, User.Username).filter(User.UserID.in_(receiver_ids)).all()
    )
    receiver_map = {r.UserID: r.Username for r in receivers}

    # Write rows
    for t in transactions:
        receiver_username = receiver_map.get(t.ReceiverID, "") if t.ReceiverID else ""
        writer.writerow(
            [
                t.TransactionID,
                t.Username,
                f"{float(t.Amount):.2f}",
                t.Status,
                t.Timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                t.TransactionType,
                receiver_username,
            ]
        )

    # Prepare streaming response
    output.seek(0)
    filename = f"transactions_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename={filename}"},
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/rbac_controller.py
<DOCUMENT>
# app/controllers/rbac.py
from sqlalchemy.orm import Session
from app.core.exceptions import CustomHTTPException
from app.models.admin import Admin
from app.models.rbac import Role, Permission, RolePermission
from app.schemas.rbac_schema import (
    PermissionUpdate,
    RoleCreate,
    PermissionCreate,
    RolePermissionCreate,
    RolePermissionRemove,
    RoleUpdate,
)
from app.core.responses import success_response
from typing import Union, List


def create_role(role_input: Union[RoleCreate, List[RoleCreate]], db: Session):
    # Normalize input to a list
    roles_to_create = [role_input] if isinstance(role_input, RoleCreate) else role_input
    if not roles_to_create:
        raise CustomHTTPException(status_code=400, message="No roles provided")

    new_roles = []
    existing_roles = []
    role_names = {role.RoleName for role in roles_to_create}

    # Check for existing roles
    existing = db.query(Role).filter(Role.RoleName.in_(role_names)).all()
    existing_names = {r.RoleName for r in existing}

    for role in roles_to_create:
        if role.RoleName in existing_names:
            existing_roles.append(role.RoleName)
        else:
            new_roles.append(Role(**role.model_dump()))

    if not new_roles:
        raise CustomHTTPException(
            status_code=400, message="All provided roles already exist"
        )

    try:
        db.add_all(new_roles)
        db.commit()
        for role in new_roles:
            db.refresh(role)
        return success_response(
            message=f"Created {len(new_roles)} role(s) successfully",
            data={
                "created_roles": [
                    {"RoleID": r.RoleID, "RoleName": r.RoleName} for r in new_roles
                ],
                "skipped_roles": existing_roles,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to create roles", details={"error": str(e)}
        )


def list_roles(db: Session):
    roles = db.query(Role).all()
    return success_response(
        message="Roles retrieved",
        data={
            "roles": [
                {
                    "RoleID": r.RoleID,
                    "RoleName": r.RoleName,
                    "Description": r.Description,
                }
                for r in roles
            ]
        },
    )


def create_permission(
    perm_input: Union[PermissionCreate, List[PermissionCreate]], db: Session
):
    # Normalize input to a list
    perms_to_create = (
        [perm_input] if isinstance(perm_input, PermissionCreate) else perm_input
    )
    if not perms_to_create:
        raise CustomHTTPException(status_code=400, message="No permissions provided")

    new_perms = []
    existing_perms = []
    perm_names = {perm.PermissionName for perm in perms_to_create}

    # Check for existing permissions
    existing = (
        db.query(Permission).filter(Permission.PermissionName.in_(perm_names)).all()
    )
    existing_names = {p.PermissionName for p in existing}

    for perm in perms_to_create:
        if perm.PermissionName in existing_names:
            existing_perms.append(perm.PermissionName)
        else:
            new_perms.append(Permission(**perm.model_dump()))

    if not new_perms:
        raise CustomHTTPException(
            status_code=400, message="All provided permissions already exist"
        )

    try:
        db.add_all(new_perms)
        db.commit()
        for perm in new_perms:
            db.refresh(perm)
        return success_response(
            message=f"Created {len(new_perms)} permission(s) successfully",
            data={
                "created_permissions": [
                    {"PermissionID": p.PermissionID, "PermissionName": p.PermissionName}
                    for p in new_perms
                ],
                "skipped_permissions": existing_perms,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500,
            message="Failed to create permissions",
            details={"error": str(e)},
        )


def list_permissions(db: Session):
    perms = db.query(Permission).all()
    return success_response(
        message="Permissions retrieved",
        data={
            "permissions": [
                {
                    "PermissionID": p.PermissionID,
                    "PermissionName": p.PermissionName,
                    "Description": p.Description,
                }
                for p in perms
            ]
        },
    )


def assign_permissions_to_role(rp: RolePermissionCreate, db: Session):
    role = db.query(Role).filter(Role.RoleID == rp.RoleID).first()
    if not role:
        raise CustomHTTPException(status_code=404, message="Role not found")

    # Normalize PermissionID to a list
    permission_ids = (
        [rp.PermissionID] if isinstance(rp.PermissionID, int) else rp.PermissionID
    )
    if not permission_ids:
        raise CustomHTTPException(status_code=400, message="No permissions provided")

    invalid_permissions = []
    existing_assignments = []
    new_role_permissions = []

    for perm_id in permission_ids:
        permission = (
            db.query(Permission).filter(Permission.PermissionID == perm_id).first()
        )
        if not permission:
            invalid_permissions.append(perm_id)
        elif (
            db.query(RolePermission)
            .filter(
                RolePermission.RoleID == rp.RoleID,
                RolePermission.PermissionID == perm_id,
            )
            .first()
        ):
            existing_assignments.append(perm_id)
        else:
            new_role_permissions.append(
                RolePermission(RoleID=rp.RoleID, PermissionID=perm_id)
            )

    if invalid_permissions:
        raise CustomHTTPException(
            status_code=404,
            message=f"Permissions not found: {', '.join(map(str, invalid_permissions))}",
        )

    if not new_role_permissions:
        raise CustomHTTPException(
            status_code=400,
            message=(
                "All provided permissions are already assigned to the role"
                if existing_assignments
                else "No valid permissions provided"
            ),
        )

    try:
        db.add_all(new_role_permissions)
        db.commit()
        assigned_count = len(new_role_permissions)
        return success_response(
            message=f"Assigned {assigned_count} permission(s) to role successfully",
            data={
                "RoleID": rp.RoleID,
                "AssignedPermissionIDs": [
                    rp.PermissionID for rp in new_role_permissions
                ],
                "SkippedPermissionIDs": existing_assignments,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500,
            message="Failed to assign permissions",
            details={"error": str(e)},
        )


def update_role(role_id: int, role_update: RoleUpdate, db: Session):
    role = db.query(Role).filter(Role.RoleID == role_id).first()
    if not role:
        raise CustomHTTPException(status_code=404, message="Role not found")

    update_data = role_update.model_dump(exclude_unset=True)
    if "RoleName" in update_data and update_data["RoleName"] != role.RoleName:
        if db.query(Role).filter(Role.RoleName == update_data["RoleName"]).first():
            raise CustomHTTPException(
                status_code=400, message="Role name already exists"
            )

    for key, value in update_data.items():
        setattr(role, key, value)

    try:
        db.commit()
        db.refresh(role)
        return success_response(
            message="Role updated successfully",
            data={
                "RoleID": role.RoleID,
                "RoleName": role.RoleName,
                "Description": role.Description,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to update role", details={"error": str(e)}
        )


def delete_role(role_id: int, db: Session):
    role = db.query(Role).filter(Role.RoleID == role_id).first()
    if not role:
        raise CustomHTTPException(status_code=404, message="Role not found")

    # Check if role is assigned to admins
    if db.query(Admin).filter(Admin.RoleID == role_id).count() > 0:
        raise CustomHTTPException(
            status_code=400, message="Cannot delete role assigned to admins"
        )

    try:
        db.delete(role)
        db.commit()
        return success_response(
            message="Role deleted successfully", data={"RoleID": role_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to delete role", details={"error": str(e)}
        )


def update_permission(permission_id: int, perm_update: PermissionUpdate, db: Session):
    permission = (
        db.query(Permission).filter(Permission.PermissionID == permission_id).first()
    )
    if not permission:
        raise CustomHTTPException(status_code=404, message="Permission not found")

    update_data = perm_update.model_dump(exclude_unset=True)
    if (
        "PermissionName" in update_data
        and update_data["PermissionName"] != permission.PermissionName
    ):
        if (
            db.query(Permission)
            .filter(Permission.PermissionName == update_data["PermissionName"])
            .first()
        ):
            raise CustomHTTPException(
                status_code=400, message="Permission name already exists"
            )

    for key, value in update_data.items():
        setattr(permission, key, value)

    try:
        db.commit()
        db.refresh(permission)
        return success_response(
            message="Permission updated successfully",
            data={
                "PermissionID": permission.PermissionID,
                "PermissionName": permission.PermissionName,
                "Description": permission.Description,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500,
            message="Failed to update permission",
            details={"error": str(e)},
        )


def delete_permission(permission_id: int, db: Session):
    permission = (
        db.query(Permission).filter(Permission.PermissionID == permission_id).first()
    )
    if not permission:
        raise CustomHTTPException(status_code=404, message="Permission not found")

    # Check if permission is assigned to roles
    if (
        db.query(RolePermission)
        .filter(RolePermission.PermissionID == permission_id)
        .count()
        > 0
    ):
        raise CustomHTTPException(
            status_code=400, message="Cannot delete permission assigned to roles"
        )

    try:
        db.delete(permission)
        db.commit()
        return success_response(
            message="Permission deleted successfully",
            data={"PermissionID": permission_id},
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500,
            message="Failed to delete permission",
            details={"error": str(e)},
        )


def remove_permissions_from_role(rp_remove: RolePermissionRemove, db: Session):
    role = db.query(Role).filter(Role.RoleID == rp_remove.RoleID).first()
    if not role:
        raise CustomHTTPException(status_code=404, message="Role not found")

    permission_ids = (
        [rp_remove.PermissionID]
        if isinstance(rp_remove.PermissionID, int)
        else rp_remove.PermissionID
    )
    if not permission_ids:
        raise CustomHTTPException(status_code=400, message="No permissions provided")

    invalid_permissions = []
    not_assigned_permissions = []
    role_permissions_to_remove = []

    for perm_id in permission_ids:
        permission = (
            db.query(Permission).filter(Permission.PermissionID == perm_id).first()
        )
        if not permission:
            invalid_permissions.append(perm_id)
        else:
            rp = (
                db.query(RolePermission)
                .filter(
                    RolePermission.RoleID == rp_remove.RoleID,
                    RolePermission.PermissionID == perm_id,
                )
                .first()
            )
            if not rp:
                not_assigned_permissions.append(perm_id)
            else:
                role_permissions_to_remove.append(rp)

    if invalid_permissions:
        raise CustomHTTPException(
            status_code=404,
            message=f"Permissions not found: {', '.join(map(str, invalid_permissions))}",
        )

    if not role_permissions_to_remove:
        raise CustomHTTPException(
            status_code=400,
            message=(
                "No valid permissions to remove"
                if not_assigned_permissions
                else "All provided permissions are not assigned to the role"
            ),
            details={"not_assigned": not_assigned_permissions},
        )

    try:
        for rp in role_permissions_to_remove:
            db.delete(rp)
        db.commit()
        return success_response(
            message=f"Removed {len(role_permissions_to_remove)} permission(s) from role successfully",
            data={
                "RoleID": rp_remove.RoleID,
                "RemovedPermissionIDs": [
                    rp.PermissionID for rp in role_permissions_to_remove
                ],
                "SkippedPermissionIDs": not_assigned_permissions,
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500,
            message="Failed to remove permissions",
            details={"error": str(e)},
        )


# List permissions for a specific role
def list_role_permissions(role_id: int, db: Session):
    role = db.query(Role).filter(Role.RoleID == role_id).first()
    if not role:
        raise CustomHTTPException(status_code=404, message="Role not found")

    permissions = (
        db.query(Permission)
        .join(RolePermission, RolePermission.PermissionID == Permission.PermissionID)
        .filter(RolePermission.RoleID == role_id)
        .all()
    )
    return success_response(
        message="Role permissions retrieved",
        data={
            "RoleID": role_id,
            "RoleName": role.RoleName,
            "permissions": [
                {
                    "PermissionID": p.PermissionID,
                    "PermissionName": p.PermissionName,
                    "Description": p.Description,
                }
                for p in permissions
            ],
        },
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/user_controller.py
<DOCUMENT>
from io import StringIO
import csv
from typing import Optional
from fastapi.responses import StreamingResponse
from fastapi import Depends, status
from sqlalchemy.orm import Session, aliased
from app.core.exceptions import CustomHTTPException, DatabaseError
from app.schemas.user_schema import (
    UserCreate,
    UserLogin,
    UserPasswordUpdate,
    UserResponseData,
    LoginResponseData,
    UserUpdate,
)
from app.models.user import User
from app.core.database import get_db
from app.core.responses import success_response
from app.core.utils import hash_password, check_unique_field
from app.core.auth import create_access_token, create_refresh_token
from passlib.context import CryptContext
from datetime import datetime, timezone
from sqlalchemy import case, func, or_
from app.models.deposit import Deposit
from app.models.transfer import Transfer
from app.models.withdrawal import Withdrawal
from app.models.loan import Loan

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def register_user(user: UserCreate, db: Session = Depends(get_db)):
    for field in ["Email", "CNIC", "Username"]:
        check_unique_field(db, User, field, getattr(user, field))

    try:
        new_user = User(**user.model_dump(exclude={"Password"}))
        new_user.Password = hash_password(user.Password)

        db.add(new_user)
        db.commit()
        db.refresh(new_user)

        return success_response(
            message="User registered successfully, pending admin approval",
            data=UserResponseData.model_validate(new_user).model_dump(),
            status_code=status.HTTP_201_CREATED,
        )
    except Exception as e:
        db.rollback()
        raise DatabaseError(f"Database error: {str(e)}")


def login_user(credentials: UserLogin, db: Session = Depends(get_db)):
    user = (
        db.query(User)
        .filter(
            (User.Email == credentials.login_id)
            | (User.Username == credentials.login_id)
        )
        .first()
    )

    if not user or not pwd_context.verify(credentials.Password, user.Password):
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, message="Invalid credentials"
        )

    if not user.IsActive:  #  Prevent login if inactive
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN, message="Account is pending approval"
        )

    user.LastLogin = datetime.now(timezone.utc)
    db.commit()

    access_token = create_access_token(data={"sub": str(user.UserID), "role_id": 0})
    refresh_token = create_refresh_token(data={"sub": str(user.UserID), "role_id": 0})
    return success_response(
        message="Login successful",
        data={
            **LoginResponseData.model_validate(user).model_dump(),
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
        },
    )


def update_current_user(user_id: int, user_update: UserUpdate, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    # Prevent users from updating sensitive fields
    restricted_fields = {"IsActive", "Balance", "Password", "AccountType"}
    if any(
        field in restricted_fields
        for field in user_update.model_dump(exclude_unset=True).keys()
    ):
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            message="Cannot update restricted fields (e.g., IsActive, Balance, Password) via this endpoint. Use /me/password for password changes.",
        )

    # Check for unique constraints
    if user_update.Username and user_update.Username != user.Username:
        if db.query(User).filter(User.Username == user_update.Username).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Username already exists",
            )
    if user_update.Email and user_update.Email != user.Email:
        if db.query(User).filter(User.Email == user_update.Email).first():
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Email already exists"
            )

    # Apply updates
    update_data = user_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(user, key, value)

    try:
        db.commit()
        db.refresh(user)
        return success_response(
            message="Profile updated successfully",
            data=UserResponseData.model_validate(user).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to update profile",
            details={"error": str(e)},
        )


def update_user_password(
    user_id: int, password_update: UserPasswordUpdate, db: Session
):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    # Verify current password
    if not pwd_context.verify(password_update.CurrentPassword, user.Password):
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Current password is incorrect",
        )

    # Update password
    user.Password = pwd_context.hash(password_update.NewPassword)

    try:
        db.commit()
        db.refresh(user)
        return success_response(
            message="Password updated successfully", data={"UserID": user.UserID}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to update password",
            details={"error": str(e)},
        )


def get_user_profile(user_id: int, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )
    return success_response(
        message="User details retrieved successfully",
        data=UserResponseData(
            UserID=user.UserID,
            Username=user.Username,
            FirstName=user.FirstName,
            LastName=user.LastName,
            StreetAddress=user.StreetAddress,
            City=user.City,
            State=user.State,
            Country=user.Country,
            PostalCode=user.PostalCode,
            PhoneNumber=user.PhoneNumber,
            CNIC=user.CNIC,
            Email=user.Email,
            AccountType=user.AccountType,
            Balance=user.Balance,
            IsActive=user.IsActive,
            DateOfBirth=user.DateOfBirth.isoformat() if user.DateOfBirth else None,
            CreatedAt=user.CreatedAt.isoformat() if user.CreatedAt else None,
            LastLogin=user.LastLogin.isoformat() if user.LastLogin else None,
            access_token="",
            refresh_token="",
            token_type="bearer",
        ).model_dump(exclude={"access_token", "refresh_token"}),
    )


def get_user_analytics_summary(user_id: int, db: Session):
    # Total Transactions
    deposit_count = (
        db.query(Deposit)
        .filter(Deposit.UserID == user_id, Deposit.Status == "Completed")
        .count()
    )
    deposit_total = (
        db.query(func.sum(Deposit.Amount))
        .filter(Deposit.UserID == user_id, Deposit.Status == "Completed")
        .scalar()
        or 0
    )

    transfer_sent_count = (
        db.query(Transfer)
        .filter(Transfer.SenderID == user_id, Transfer.Status == "Completed")
        .count()
    )
    transfer_sent_total = (
        db.query(func.sum(Transfer.Amount))
        .filter(Transfer.SenderID == user_id, Transfer.Status == "Completed")
        .scalar()
        or 0
    )

    transfer_received_count = (
        db.query(Transfer)
        .filter(Transfer.ReceiverID == user_id, Transfer.Status == "Completed")
        .count()
    )
    transfer_received_total = (
        db.query(func.sum(Transfer.Amount))
        .filter(Transfer.ReceiverID == user_id, Transfer.Status == "Completed")
        .scalar()
        or 0
    )

    withdrawal_count = (
        db.query(Withdrawal)
        .filter(Withdrawal.UserID == user_id, Withdrawal.Status == "Completed")
        .count()
    )
    withdrawal_total = (
        db.query(func.sum(Withdrawal.Amount))
        .filter(Withdrawal.UserID == user_id, Withdrawal.Status == "Completed")
        .scalar()
        or 0
    )

    total_transaction_count = (
        deposit_count + transfer_sent_count + transfer_received_count + withdrawal_count
    )
    total_transaction_volume = float(
        deposit_total + transfer_sent_total + transfer_received_total + withdrawal_total
    )

    # Average Transaction Amount
    avg_transaction_amount = (
        total_transaction_volume / total_transaction_count
        if total_transaction_count > 0
        else 0
    )

    # Total Loan Amounts
    total_loan_amount = (
        db.query(func.sum(Loan.LoanAmount))
        .filter(Loan.UserID == user_id, Loan.LoanStatus == "Approved")
        .scalar()
        or 0
    )
    total_loan_count = (
        db.query(Loan)
        .filter(Loan.UserID == user_id, Loan.LoanStatus == "Approved")
        .count()
    )

    # Pending Loans
    pending_loan_count = (
        db.query(Loan)
        .filter(Loan.UserID == user_id, Loan.LoanStatus == "Pending")
        .count()
    )

    # Current Balance
    user = db.query(User).filter(User.UserID == user_id).first()
    current_balance = float(user.Balance) if user else 0

    return success_response(
        message="User analytics summary retrieved successfully",
        data={
            "transactions": {
                "total_count": total_transaction_count,
                "total_volume": total_transaction_volume,
                "deposits": {
                    "count": deposit_count,
                    "amount": float(deposit_total),
                },
                "transfers_sent": {
                    "count": transfer_sent_count,
                    "amount": float(transfer_sent_total),
                },
                "transfers_received": {
                    "count": transfer_received_count,
                    "amount": float(transfer_received_total),
                },
                "withdrawals": {
                    "count": withdrawal_count,
                    "amount": float(withdrawal_total),
                },
                "average_amount": float(avg_transaction_amount),
            },
            "loans": {
                "total_approved_amount": float(total_loan_amount),
                "total_approved_count": total_loan_count,
                "pending_count": pending_loan_count,
            },
            "current_balance": current_balance,
        },
    )


def export_user_transactions(
    user_id: int,
    db: Session,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    transaction_status: Optional[str] = None,
    transaction_type: Optional[str] = None,
):
    # Alias the Transfers table for sent and received transactions
    TransfersSent = aliased(Transfer, name="TransfersSent")
    TransfersReceived = aliased(Transfer, name="TransfersReceived")

    # Start query from User table to avoid ambiguity
    query = (
        db.query(User)  # Start with User as the base table
        .filter(User.UserID == user_id)
        .outerjoin(Deposit, Deposit.UserID == User.UserID)
        .outerjoin(TransfersSent, TransfersSent.SenderID == User.UserID)
        .outerjoin(TransfersReceived, TransfersReceived.ReceiverID == User.UserID)
        .outerjoin(Withdrawal, Withdrawal.UserID == User.UserID)
        .with_entities(
            func.coalesce(
                Deposit.DepositID,
                TransfersSent.TransferID,
                TransfersReceived.TransferID,
                Withdrawal.WithdrawalID,
            ).label("TransactionID"),
            func.coalesce(
                Deposit.Amount,
                TransfersSent.Amount,
                TransfersReceived.Amount,
                Withdrawal.Amount,
            ).label("Amount"),
            func.coalesce(
                Deposit.Status,
                TransfersSent.Status,
                TransfersReceived.Status,
                Withdrawal.Status,
            ).label("Status"),
            func.coalesce(
                Deposit.Timestamp,
                TransfersSent.Timestamp,
                TransfersReceived.Timestamp,
                Withdrawal.Timestamp,
            ).label("Timestamp"),
            case(
                (Deposit.DepositID.isnot(None), "Deposit"),
                (TransfersSent.TransferID.isnot(None), "Transfer (Sent)"),
                (TransfersReceived.TransferID.isnot(None), "Transfer (Received)"),
                (Withdrawal.WithdrawalID.isnot(None), "Withdrawal"),
            ).label("TransactionType"),
            func.coalesce(TransfersSent.ReceiverID, TransfersReceived.ReceiverID).label(
                "ReceiverID"
            ),
        )
        .filter(
            or_(
                Deposit.DepositID.isnot(None),
                TransfersSent.TransferID.isnot(None),
                TransfersReceived.TransferID.isnot(None),
                Withdrawal.WithdrawalID.isnot(None),
            )
        )
    )

    # Apply filters
    if start_date:
        query = query.filter(
            func.coalesce(
                Deposit.Timestamp,
                TransfersSent.Timestamp,
                TransfersReceived.Timestamp,
                Withdrawal.Timestamp,
            )
            >= start_date
        )
    if end_date:
        query = query.filter(
            func.coalesce(
                Deposit.Timestamp,
                TransfersSent.Timestamp,
                TransfersReceived.Timestamp,
                Withdrawal.Timestamp,
            )
            <= end_date
        )
    if transaction_status:
        if transaction_status not in ["Pending", "Completed", "Failed"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction status value",
            )
        query = query.filter(
            func.coalesce(
                Deposit.Status,
                TransfersSent.Status,
                TransfersReceived.Status,
                Withdrawal.Status,
            )
            == transaction_status
        )
    if transaction_type:
        if transaction_type not in [
            "Deposit",
            "Transfer (Sent)",
            "Transfer (Received)",
            "Withdrawal",
        ]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction type value",
            )
        if transaction_type == "Deposit":
            query = query.filter(Deposit.DepositID.isnot(None))
        elif transaction_type == "Transfer (Sent)":
            query = query.filter(TransfersSent.TransferID.isnot(None))
        elif transaction_type == "Transfer (Received)":
            query = query.filter(TransfersReceived.TransferID.isnot(None))
        elif transaction_type == "Withdrawal":
            query = query.filter(Withdrawal.WithdrawalID.isnot(None))

    # Execute query
    transactions = query.all()

    if not transactions:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            message="No transactions found for export",
        )

    # Create CSV in memory
    output = StringIO()
    writer = csv.writer(output, quoting=csv.QUOTE_MINIMAL)

    # Write headers
    headers = [
        "TransactionID",
        "Amount",
        "Status",
        "Timestamp",
        "TransactionType",
        "ReceiverUsername",
    ]
    writer.writerow(headers)

    # Fetch receiver usernames for transfers
    receiver_ids = {t.ReceiverID for t in transactions if t.ReceiverID}
    receivers = (
        db.query(User.UserID, User.Username).filter(User.UserID.in_(receiver_ids)).all()
    )
    receiver_map = {r.UserID: r.Username for r in receivers}

    # Write rows
    for t in transactions:
        receiver_username = receiver_map.get(t.ReceiverID, "") if t.ReceiverID else ""
        writer.writerow(
            [
                t.TransactionID,
                f"{float(t.Amount):.2f}",
                t.Status,
                t.Timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                t.TransactionType,
                receiver_username,
            ]
        )

    # Prepare streaming response
    output.seek(0)
    filename = f"my_transactions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename={filename}"},
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/cards/admins.py
<DOCUMENT>
from typing import Optional
from sqlalchemy.orm import Session
from app.models.card import Card
from app.schemas.card_schema import CardUpdate, CardResponse
from app.core.responses import success_response
from app.core.exceptions import CustomHTTPException
from app.core.auth import pwd_context


def list_all_cards(
    db: Session, page: int = 1, per_page: int = 10, user_id: Optional[int] = None
):
    query = db.query(Card)

    # Apply user_id filter if provided
    if user_id is not None:
        query = query.filter(Card.UserID == user_id)

    # Get total count for pagination
    total_items = query.count()

    # Calculate total pages
    total_pages = (total_items + per_page - 1) // per_page  # Ceiling division

    # Apply pagination
    cards = query.offset((page - 1) * per_page).limit(per_page).all()

    # Prepare response message
    message = (
        "No cards found"
        if not cards
        else (
            f"Cards retrieved successfully for user {user_id}"
            if user_id is not None
            else "All cards retrieved successfully"
        )
    )

    return {
        "success": True,
        "message": message,
        "data": {
            "cards": [CardResponse.model_validate(card).model_dump() for card in cards]
        },
        "page": page,
        "per_page": per_page,
        "total_items": total_items,
        "total_pages": total_pages,
    }


def block_card(card_id: int, db: Session):
    card = db.query(Card).filter(Card.CardID == card_id).first()
    if not card:
        raise CustomHTTPException(status_code=404, message="Card not found")
    if card.Status == "Blocked":
        raise CustomHTTPException(status_code=400, message="Card is already blocked")

    card.Status = "Blocked"
    try:
        db.commit()
        db.refresh(card)
        return success_response(
            message="Card blocked successfully",
            data=CardResponse.model_validate(card).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to block card", details={"error": str(e)}
        )


def update_card_admin(card_id: int, card_update: CardUpdate, db: Session):
    card = db.query(Card).filter(Card.CardID == card_id).first()
    if not card:
        raise CustomHTTPException(status_code=404, message="Card not found")

    update_data = card_update.model_dump(exclude_unset=True)
    if "Pin" in update_data:
        update_data["Pin"] = pwd_context.hash(update_data["Pin"])

    for key, value in update_data.items():
        setattr(card, key, value)

    try:
        db.commit()
        db.refresh(card)
        return success_response(
            message="Card updated successfully by admin",
            data=CardResponse.model_validate(card).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to update card", details={"error": str(e)}
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/cards/users.py
<DOCUMENT>
from datetime import date
from sqlalchemy import asc, desc, func
from sqlalchemy.orm import Session
from app.core.schemas import PaginatedResponse
from app.models.card import Card
from app.schemas.card_schema import CardCreate, CardUpdate, CardResponse
from app.core.responses import success_response
from app.core.exceptions import CustomHTTPException
from app.core.auth import pwd_context
from fastapi import status


def create_card(user_id: int, card: CardCreate, db: Session):
    if card.ExpirationDate <= date.today():
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Invalid ExpirationDate. The card expiration date must be in the future.",
        )

    existing_active_card = (
        db.query(Card).filter(Card.UserID == user_id, Card.Status == "Active").first()
    )
    if existing_active_card:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="User already has an active card",
        )

    new_card = Card(
        UserID=user_id,
        CardNumber=card.CardNumber,
        Pin=pwd_context.hash(card.Pin),
        ExpirationDate=card.ExpirationDate,
        Status="Active",
    )

    try:
        db.add(new_card)
        db.commit()
        db.refresh(new_card)
        return success_response(
            message="Card created successfully",
            data=CardResponse.model_validate(new_card).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to create card",
            details={"error": str(e)},
        )


def list_cards(
    user_id: int,
    db: Session,
    page: int = 1,
    per_page: int = 10,
    sort_by: str = "CardID",
    order: str = "asc",
):
    query = db.query(Card).filter(Card.UserID == user_id)

    # Get total count for pagination
    total_items = query.count()

    # Calculate total pages
    total_pages = (total_items + per_page - 1) // per_page

    # Define sortable columns
    sort_columns = {
        "CardID": Card.CardID,
        "ExpirationDate": Card.ExpirationDate,
        "Status": Card.Status,
        "CardNumber": Card.CardNumber,
    }
    sort_column = sort_columns.get(sort_by, Card.CardID)  # Default to CardID
    order_func = desc if order.lower() == "desc" else asc

    # Apply ordering
    query = query.order_by(order_func(sort_column))

    # Apply pagination
    cards = query.offset((page - 1) * per_page).limit(per_page).all()

    # Return PaginatedResponse
    return PaginatedResponse(
        success=True,
        message="No cards found" if not cards else "Cards retrieved successfully",
        data={
            "cards": [CardResponse.model_validate(card).model_dump() for card in cards]
        },
        page=page,
        per_page=per_page,
        total_items=total_items,
        total_pages=total_pages,
    )


def update_card(user_id: int, card_id: int, card_update: CardUpdate, db: Session):
    card = db.query(Card).filter(Card.CardID == card_id, Card.UserID == user_id).first()
    if not card:
        raise CustomHTTPException(
            status_code=404, message="Card not found or not owned by user"
        )

    if card.Status == "Blocked":
        raise CustomHTTPException(
            status_code=403, message="Blocked cards cannot be updated by users"
        )

    update_data = card_update.model_dump(exclude_unset=True)
    if "Pin" in update_data:
        update_data["Pin"] = pwd_context.hash(update_data["Pin"])
    if "Status" in update_data and update_data["Status"] == "Blocked":
        raise CustomHTTPException(
            status_code=403, message="Users cannot block their own cards"
        )

    for key, value in update_data.items():
        setattr(card, key, value)

    try:
        db.commit()
        db.refresh(card)
        return success_response(
            message="Card updated successfully",
            data=CardResponse.model_validate(card).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to update card", details={"error": str(e)}
        )


def delete_card(user_id: int, card_id: int, db: Session):
    card = db.query(Card).filter(Card.CardID == card_id, Card.UserID == user_id).first()
    if not card:
        raise CustomHTTPException(
            status_code=404, message="Card not found or not owned by user"
        )
    if card.Status == "Blocked":
        raise CustomHTTPException(
            status_code=403, message="Blocked cards cannot be deleted by users"
        )

    try:
        db.delete(card)
        db.commit()
        return success_response(
            message="Card deleted successfully", data={"CardID": card_id}
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=500, message="Failed to delete card", details={"error": str(e)}
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/deposits/admins.py
<DOCUMENT>
from sqlalchemy.orm import Session
from decimal import Decimal
from app.models.deposit import Deposit
from app.models.user import User
from app.schemas.deposit_schema import DepositCreate, DepositResponse
from app.core.responses import success_response
from app.core.exceptions import CustomHTTPException
from app.core.event_emitter import emit_event  # Add this import
from fastapi import status
import uuid
from fastapi import BackgroundTasks


async def create_deposit(
    user_id: int, 
    admin_id: int, 
    deposit: DepositCreate, 
    db: Session,
    background_tasks: BackgroundTasks
):
    user = db.query(User).filter(User.UserID == user_id).with_for_update().first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            message="User not found"
        )

    amount = Decimal(str(deposit.Amount))
    if amount <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Deposit amount must be positive",
        )

    new_deposit = Deposit(
        UserID=user_id,
        AdminID=admin_id,
        Amount=amount,
        ReferenceNumber=str(uuid.uuid4()),
        Status="Pending",
        Description=deposit.Description or "Admin-initiated deposit",
    )

    try:
        user.Balance += amount
        new_deposit.Status = "Completed"
        db.add(new_deposit)
        db.commit()
        db.refresh(new_deposit)

        # Emit real-time notification to user
        await emit_event(
            "deposit_completed",
            {
                "amount": float(amount),
                "balance": float(user.Balance),
                "reference": new_deposit.ReferenceNumber,
                "timestamp": str(new_deposit.Timestamp)
            },
            user_id=user_id,
            background_tasks=background_tasks
        )

        # Notify admins about the deposit
        await emit_event(
            "deposit_processed",
            {
                "user_id": user_id,
                "amount": float(amount),
                "admin_id": admin_id,
                "reference": new_deposit.ReferenceNumber
            },
            broadcast=True,
            background_tasks=background_tasks
        )

        return success_response(
            message="Deposit completed successfully",
            data=DepositResponse.model_validate(new_deposit).model_dump(),
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Deposit failed",
            details={"error": str(e)},
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/loans/admins.py
<DOCUMENT>
from sqlalchemy.orm import Session
from sqlalchemy import func, asc, desc, text
from app.models.loan import Loan, LoanType
from app.models.user import User
from app.models.admin import Admin
from app.schemas.loan_schema import LoanResponse
from app.core.responses import success_response
from app.core.schemas import PaginatedResponse
from app.core.exceptions import CustomHTTPException
from fastapi import status
from datetime import date
from typing import Optional
from fastapi import BackgroundTasks
from app.core.event_emitter import emit_event


async def approve_loan(
    loan_id: int,
    current_admin: Admin,
    db: Session,
    background_tasks: BackgroundTasks,
):
    loan = db.query(Loan).filter(Loan.LoanID == loan_id).first()
    if not loan:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Loan not found"
        )
    if loan.LoanStatus != "Pending":
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Only pending loans can be approved",
        )

    try:
        loan.LoanStatus = "Active"
        db.execute(
            text(
                "EXEC UpdateUserBalance @UserID=:user_id, @Amount=:amount, @TransactionType='LoanApproved', @EntityID=:loan_id"
            ),
            {
                "user_id": loan.UserID,
                "amount": float(loan.LoanAmount),
                "loan_id": loan_id,
            },
        )
        db.commit()

        # Emit notification to the loan applicant (user)
        await emit_event(
            "loan_status_updated",
            {
                "loan_id": loan_id,
                "status": "Active",
                "admin_id": current_admin.AdminID,
            },
            user_id=loan.UserID,
            background_tasks=background_tasks,
        )

        # Emit notification to all admins
        await emit_event(
            "loan_processed",
            {
                "loan_id": loan_id,
                "status": "Active",
                "admin_id": current_admin.AdminID,
                "user_id": loan.UserID,
            },
            broadcast=True,
            background_tasks=background_tasks,
        )

        return success_response(
            message="Loan approved successfully",
            data={"loan_id": loan_id, "status": "Active"},
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to approve loan",
            details={"error": str(e)},
        )


async def reject_loan(
    loan_id: int,
    current_admin: Admin,
    db: Session,
    background_tasks: BackgroundTasks,
):
    loan = db.query(Loan).filter(Loan.LoanID == loan_id).first()
    if not loan:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Loan not found"
        )
    if loan.LoanStatus != "Pending":
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Only pending loans can be rejected",
        )

    try:
        db.commit()

        await emit_event(
            "loan_status_updated",
            {
                "loan_id": loan_id,
                "status": "Pending",
                "rejected": True,
                "admin_id": current_admin.AdminID,
            },
            user_id=loan.UserID,
            background_tasks=background_tasks,
        )
        await emit_event(
            "loan_processed",
            {
                "loan_id": loan_id,
                "status": "Pending",
                "rejected": True,
                "admin_id": current_admin.AdminID,
                "user_id": loan.UserID,
            },
            broadcast=True,
            background_tasks=background_tasks,
        )

        return success_response(
            message="Loan rejected successfully",
            data={"loan_id": loan_id, "status": "Rejected"},
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Failed to reject loan",
            details={"error": str(e)},
        )


def get_all_loans(
    db: Session,
    page: int = 1,
    per_page: int = 10,
    loan_status: Optional[str] = None,
    user_id: Optional[int] = None,
    loan_type_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    sort_by: Optional[str] = "CreatedAt",
    order: Optional[str] = "desc",
):
    query = db.query(Loan, LoanType.LoanTypeName).join(
        LoanType, Loan.LoanTypeID == LoanType.LoanTypeID
    )

    if loan_status:
        if loan_status not in ["Pending", "Approved", "Rejected", "Repaid"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Invalid loan status"
            )
        query = query.filter(Loan.LoanStatus == loan_status)

    if user_id:
        query = query.filter(Loan.UserID == user_id)

    if loan_type_id:
        query = query.filter(Loan.LoanTypeID == loan_type_id)

    if start_date and end_date:
        if start_date > end_date:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="start_date must be before end_date",
            )
        query = query.filter(Loan.CreatedAt.between(start_date, end_date))
    elif start_date:
        query = query.filter(Loan.CreatedAt >= start_date)
    elif end_date:
        query = query.filter(Loan.CreatedAt <= end_date)

    total_loans = query.count()

    sort_column = {
        "CreatedAt": Loan.CreatedAt,
        "DueDate": Loan.DueDate,
        "LoanAmount": Loan.LoanAmount,
        "MonthlyInstallment": Loan.MonthlyInstallment,
    }.get(sort_by, Loan.CreatedAt)
    order_func = desc if order.lower() == "desc" else asc
    query = query.order_by(order_func(sort_column))

    offset = (page - 1) * per_page
    loans = query.offset(offset).limit(per_page).all()

    if not loans:
        return PaginatedResponse(
            success=True,
            message="No loans found",
            data={"loans": []},
            page=page,
            per_page=per_page,
            total_items=0,
            total_pages=0,
        )

    loan_list = [
        LoanResponse(
            LoanID=loan.LoanID,
            LoanTypeName=loan_type_name,
            LoanAmount=loan.LoanAmount,
            InterestRate=loan.InterestRate,
            LoanDurationMonths=loan.LoanDurationMonths,
            MonthlyInstallment=loan.MonthlyInstallment,
            DueDate=loan.DueDate,
            LoanStatus=loan.LoanStatus,
            CreatedAt=loan.CreatedAt.date() if loan.CreatedAt else None,
        )
        for loan, loan_type_name in loans
    ]

    total_pages = (total_loans + per_page - 1) // per_page

    return PaginatedResponse(
        success=True,
        message="Loans retrieved successfully",
        data={"loans": [loan.model_dump() for loan in loan_list]},
        page=page,
        per_page=per_page,
        total_items=total_loans,
        total_pages=total_pages,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/loans/users.py
<DOCUMENT>
from decimal import Decimal
from sqlalchemy.orm import Session
from sqlalchemy import func, asc, desc
from app.models.loan import Loan, LoanType, LoanPayment
from app.models.user import User
from app.schemas.loan_schema import (
    LoanApply,
    LoanPaymentCreate,
    LoanResponse,
    LoanPaymentResponse,
)
from app.core.responses import success_response
from app.core.schemas import PaginatedResponse
from app.core.exceptions import CustomHTTPException
from fastapi import status
from datetime import date
from typing import Optional
from dateutil.relativedelta import relativedelta


def apply_loan(user_id: int, loan: LoanApply, db: Session):
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )
    if not user.IsActive:
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            message="Inactive users cannot apply for loans",
        )

    loan_type = (
        db.query(LoanType).filter(LoanType.LoanTypeID == loan.LoanTypeID).first()
    )
    if not loan_type:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Loan type not found"
        )

    if loan.LoanAmount <= 0 or loan.LoanDurationMonths <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Invalid loan amount or duration",
        )

    new_loan = Loan(
        UserID=user_id,
        LoanTypeID=loan.LoanTypeID,
        LoanAmount=loan.LoanAmount,
        InterestRate=loan_type.DefaultInterestRate,
        LoanDurationMonths=loan.LoanDurationMonths,
        DueDate=loan.DueDate,
        LoanStatus="Pending",
    )
    try:
        db.add(new_loan)
        db.commit()
        db.refresh(new_loan)
        return success_response(
            message="Loan application submitted successfully",
            data={
                "LoanID": new_loan.LoanID,
                "MonthlyInstallment": float(new_loan.MonthlyInstallment),
            },
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message=f"Failed to apply loan: {str(e)}",
        )


def make_loan_payment(user_id: int, payment: LoanPaymentCreate, db: Session):
    # Fetch the loan and validate ownership
    loan = (
        db.query(Loan)
        .filter(Loan.LoanID == payment.LoanID, Loan.UserID == user_id)
        .first()
    )
    if not loan:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            message="Loan not found or not owned by user",
        )

    if loan.LoanStatus != "Active":
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Loan must be active to accept payments",
        )

    if payment.PaymentAmount <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Payment amount must be positive",
        )

    # Fetch the user to check balance
    user = db.query(User).filter(User.UserID == user_id).first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )

    if not user.IsActive:
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            message="Inactive users cannot make loan payments",
        )

    # Fetch loan type for late fee calculation
    loan_type = (
        db.query(LoanType).filter(LoanType.LoanTypeID == loan.LoanTypeID).first()
    )
    if not loan_type:
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Loan type not found",
        )

    # Calculate late fee based on overdue days
    payment_date = date.today()
    late_days = (
        max(0, (payment_date - loan.DueDate).days) if payment_date > loan.DueDate else 0
    )
    late_fee = Decimal(str(late_days)) * Decimal(str(loan_type.LatePaymentFeePerDay))

    # Calculate total due (principal + interest) and total paid so far
    total_due = Decimal(str(loan.LoanAmount)) + (
        Decimal(str(loan.MonthlyInstallment)) * Decimal(str(loan.LoanDurationMonths))
        - Decimal(str(loan.LoanAmount))
    )
    total_paid = db.query(func.sum(LoanPayment.PaymentAmount)).filter(
        LoanPayment.LoanID == payment.LoanID
    ).scalar() or Decimal("0")

    # Include any previous late fees in the total due
    total_late_fees_paid = db.query(func.sum(LoanPayment.LateFee)).filter(
        LoanPayment.LoanID == payment.LoanID
    ).scalar() or Decimal("0")
    total_due_with_late_fees = total_due + total_late_fees_paid + late_fee

    # Calculate remaining balance
    remaining_balance = total_due_with_late_fees - total_paid
    if remaining_balance <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Loan is already fully paid",
        )

    # Adjust payment amount to include late fee and cap at remaining balance
    total_payment_required = Decimal(str(payment.PaymentAmount)) + late_fee
    if user.Balance < total_payment_required:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message=f"Insufficient balance. Available: {float(user.Balance)}, Required: {float(total_payment_required)} (including late fee of {float(late_fee)})",
        )

    adjusted_payment_amount = min(
        Decimal(str(payment.PaymentAmount)), remaining_balance - late_fee
    )
    total_amount_deducted = adjusted_payment_amount + late_fee

    # Create the payment record
    new_payment = LoanPayment(
        LoanID=payment.LoanID,
        PaymentAmount=adjusted_payment_amount,
        PaymentDate=payment_date,
        LateFee=float(late_fee),  # Store as float for consistency
    )

    try:
        # Deduct the total amount (payment + late fee) from user balance
        user.Balance -= total_amount_deducted

        # Add payment and update loan
        db.add(new_payment)

        # Shift the due date forward by one month
        loan.DueDate = loan.DueDate + relativedelta(months=1)

        db.commit()
        db.refresh(new_payment)
        db.refresh(user)
        db.refresh(loan)

        # Check if loan is fully repaid
        total_paid = db.query(func.sum(LoanPayment.PaymentAmount)).filter(
            LoanPayment.LoanID == payment.LoanID
        ).scalar() or Decimal("0")
        total_late_fees_paid = db.query(func.sum(LoanPayment.LateFee)).filter(
            LoanPayment.LoanID == payment.LoanID
        ).scalar() or Decimal("0")
        if (total_paid + total_late_fees_paid) >= total_due_with_late_fees:
            loan.LoanStatus = "Repaid"
            db.commit()

        # Prepare response data
        response_data = {
            "PaymentID": new_payment.PaymentID,
            "PaymentAmount": float(new_payment.PaymentAmount),
            "LateFee": float(new_payment.LateFee),
            "TotalAmountDeducted": float(total_amount_deducted),
            "NewDueDate": loan.DueDate,
            "RemainingBalance": float(remaining_balance - total_amount_deducted),
            "LoanStatus": loan.LoanStatus,
        }
        if adjusted_payment_amount < Decimal(str(payment.PaymentAmount)):
            response_data["AdjustmentMessage"] = (
                f"Payment adjusted to {float(adjusted_payment_amount)} to avoid overpayment."
            )

        return success_response(
            message="Payment recorded successfully",
            data=response_data,
        )
    except Exception as e:
        db.rollback()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message=f"Failed to record payment: {str(e)}",
        )


def get_loan_types(db: Session):
    loan_types = db.query(LoanType).all()
    return success_response(
        message="Loan types retrieved successfully",
        data={
            "loan_types": [
                {
                    "LoanTypeID": lt.LoanTypeID,
                    "LoanTypeName": lt.LoanTypeName,
                    "DefaultInterestRate": float(lt.DefaultInterestRate),
                    "LatePaymentFeePerDay": float(lt.LatePaymentFeePerDay),
                }
                for lt in loan_types
            ]
        },
    )


def get_user_loans(
    user_id: int,
    db: Session,
    page: int = 1,
    per_page: int = 10,
    status: Optional[str] = None,
    sort_by: Optional[str] = "CreatedAt",
    order: Optional[str] = "desc",
):
    query = (
        db.query(Loan, LoanType.LoanTypeName)
        .join(LoanType, Loan.LoanTypeID == LoanType.LoanTypeID)
        .filter(Loan.UserID == user_id)
    )

    if status:
        if status not in ["Pending", "Approved", "Rejected", "Repaid"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Invalid status value"
            )
        query = query.filter(Loan.LoanStatus == status)

    total_loans = query.count()

    sort_column = {
        "CreatedAt": Loan.CreatedAt,
        "DueDate": Loan.DueDate,
        "LoanAmount": Loan.LoanAmount,
        "MonthlyInstallment": Loan.MonthlyInstallment,
    }.get(sort_by, Loan.CreatedAt)
    order_func = desc if order.lower() == "desc" else asc
    query = query.order_by(order_func(sort_column))

    offset = (page - 1) * per_page
    loans = query.offset(offset).limit(per_page).all()

    if not loans:
        return PaginatedResponse(
            success=True,
            message="No loans found for this user",
            data={"loans": []},
            page=page,
            per_page=per_page,
            total_items=0,
            total_pages=0,
        )

    loan_list = [
        LoanResponse(
            LoanID=loan.LoanID,
            LoanTypeName=loan_type_name,
            LoanAmount=loan.LoanAmount,
            InterestRate=loan.InterestRate,
            LoanDurationMonths=loan.LoanDurationMonths,
            MonthlyInstallment=loan.MonthlyInstallment,
            DueDate=loan.DueDate,
            LoanStatus=loan.LoanStatus,
            CreatedAt=loan.CreatedAt.date() if loan.CreatedAt else None,
        )
        for loan, loan_type_name in loans
    ]

    total_pages = (total_loans + per_page - 1) // per_page

    return PaginatedResponse(
        success=True,
        message="Loans retrieved successfully",
        data={"loans": [loan.model_dump() for loan in loan_list]},
        page=page,
        per_page=per_page,
        total_items=total_loans,
        total_pages=total_pages,
    )


def get_loan_payments(
    user_id: int, loan_id: int, db: Session, page: int = 1, per_page: int = 10
):
    loan = db.query(Loan).filter(Loan.LoanID == loan_id, Loan.UserID == user_id).first()
    if not loan:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            message="Loan not found or not owned by user",
        )

    total_payments = db.query(LoanPayment).filter(LoanPayment.LoanID == loan_id).count()

    offset = (page - 1) * per_page
    payments = (
        db.query(LoanPayment)
        .filter(LoanPayment.LoanID == loan_id)
        .order_by(LoanPayment.PaymentDate.desc())
        .offset(offset)
        .limit(per_page)
        .all()
    )

    if not payments:
        return PaginatedResponse(
            success=True,
            message="No payments found for this loan",
            data={"payments": []},
            page=page,
            per_page=per_page,
            total_items=total_payments,
            total_pages=(
                0
                if total_payments == 0
                else (total_payments + per_page - 1) // per_page
            ),
        )

    payment_list = [LoanPaymentResponse.model_validate(payment) for payment in payments]

    return PaginatedResponse(
        success=True,
        message="Payments retrieved successfully",
        data={"payments": [payment.model_dump() for payment in payment_list]},
        page=page,
        per_page=per_page,
        total_items=total_payments,
        total_pages=(total_payments + per_page - 1) // per_page,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/transactions/admins.py
<DOCUMENT>
from sqlalchemy.orm import Session
from sqlalchemy import or_, asc, desc, union_all, literal
from app.models.transfer import Transfer
from app.models.deposit import Deposit
from app.models.withdrawal import Withdrawal
from app.schemas.transfer_schema import TransferResponse
from app.schemas.deposit_schema import DepositResponse
from app.schemas.withdrawal_schema import WithdrawalResponse
from app.core.schemas import PaginatedResponse
from app.core.exceptions import CustomHTTPException
from fastapi import status
from datetime import date
from typing import Optional


def get_all_transactions(
    db: Session,
    page: int = 1,
    per_page: int = 10,
    transaction_type: Optional[str] = None,
    transaction_status: Optional[
        str
    ] = None,  # Renamed to avoid conflict with fastapi.status
    user_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    sort_by: Optional[str] = "Timestamp",
    order: Optional[str] = "desc",
):
    if transaction_type:
        if transaction_type not in ["Transfer", "Deposit", "Withdrawal"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction type",
            )
        model = {"Transfer": Transfer, "Deposit": Deposit, "Withdrawal": Withdrawal}[
            transaction_type
        ]
        query = db.query(model)
        if transaction_type == "Transfer" and user_id:
            query = query.filter(
                or_(Transfer.SenderID == user_id, Transfer.ReceiverID == user_id)
            )
        elif user_id:
            query = query.filter(model.UserID == user_id)
    else:
        transfer_query = db.query(Transfer).add_columns(
            Transfer.TransferID.label("ID"),
            Transfer.SenderID.label("UserID"),
            Transfer.ReceiverID.label("RelatedUserID"),
            Transfer.Amount.label("Amount"),
            literal("Transfer").label("TransactionType"),
            Transfer.ReferenceNumber.label("ReferenceNumber"),
            Transfer.Status.label("Status"),
            Transfer.Description.label("Description"),
            Transfer.Timestamp.label("Timestamp"),
        )
        deposit_query = db.query(Deposit).add_columns(
            Deposit.DepositID.label("ID"),
            Deposit.UserID.label("UserID"),
            Deposit.AdminID.label("RelatedUserID"),
            Deposit.Amount.label("Amount"),
            literal("Deposit").label("TransactionType"),
            Deposit.ReferenceNumber.label("ReferenceNumber"),
            Deposit.Status.label("Status"),
            Deposit.Description.label("Description"),
            Deposit.Timestamp.label("Timestamp"),
        )
        withdrawal_query = db.query(Withdrawal).add_columns(
            Withdrawal.WithdrawalID.label("ID"),
            Withdrawal.UserID.label("UserID"),
            Withdrawal.CardID.label("RelatedUserID"),
            Withdrawal.Amount.label("Amount"),
            literal("Withdrawal").label("TransactionType"),
            Withdrawal.ReferenceNumber.label("ReferenceNumber"),
            Withdrawal.Status.label("Status"),
            Withdrawal.Description.label("Description"),
            Withdrawal.Timestamp.label("Timestamp"),
        )
        union_query = union_all(transfer_query, deposit_query, withdrawal_query)
        subquery = union_query.subquery()
        query = db.query(subquery)
        if user_id:
            query = query.filter(
                or_(subquery.c.UserID == user_id, subquery.c.RelatedUserID == user_id)
            )

    if transaction_status:
        if transaction_status not in ["Pending", "Completed", "Failed"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, message="Invalid status"
            )
        if transaction_type:
            query = query.filter_by(Status=transaction_status)
        else:
            query = query.filter(subquery.c.Status == transaction_status)

    if start_date and end_date:
        if start_date > end_date:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="start_date must be before end_date",
            )
        if transaction_type:
            query = query.filter(model.Timestamp.between(start_date, end_date))
        else:
            query = query.filter(subquery.c.Timestamp.between(start_date, end_date))
    elif start_date:
        if transaction_type:
            query = query.filter(model.Timestamp >= start_date)
        else:
            query = query.filter(subquery.c.Timestamp >= start_date)
    elif end_date:
        if transaction_type:
            query = query.filter(model.Timestamp <= end_date)
        else:
            query = query.filter(subquery.c.Timestamp <= end_date)

    total_items = query.count()

    sort_column = {"Timestamp": "Timestamp", "Amount": "Amount"}.get(
        sort_by, "Timestamp"
    )
    order_func = desc if order.lower() == "desc" else asc
    if transaction_type:
        query = query.order_by(order_func(getattr(model, sort_column)))
    else:
        query = query.order_by(order_func(subquery.c[sort_column]))

    offset = (page - 1) * per_page
    transactions = query.offset(offset).limit(per_page).all()

    if not transactions:
        return PaginatedResponse(
            success=True,
            message="No transactions found",
            data={"transactions": []},
            page=page,
            per_page=per_page,
            total_items=0,
            total_pages=0,
        )

    total_pages = (total_items + per_page - 1) // per_page

    transaction_list = []
    if transaction_type:
        if transaction_type == "Transfer":
            transaction_list = [
                TransferResponse.model_validate(t).model_dump() for t in transactions
            ]
        elif transaction_type == "Deposit":
            transaction_list = [
                DepositResponse.model_validate(t).model_dump() for t in transactions
            ]
        elif transaction_type == "Withdrawal":
            transaction_list = [
                WithdrawalResponse.model_validate(t).model_dump() for t in transactions
            ]
    else:
        for t in transactions:
            if t.TransactionType == "Transfer":
                transaction_list.append(
                    TransferResponse(
                        TransferID=t.ID,
                        SenderID=t.UserID,
                        ReceiverID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )
            elif t.TransactionType == "Deposit":
                transaction_list.append(
                    DepositResponse(
                        DepositID=t.ID,
                        UserID=t.UserID,
                        AdminID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )
            elif t.TransactionType == "Withdrawal":
                transaction_list.append(
                    WithdrawalResponse(
                        WithdrawalID=t.ID,
                        UserID=t.UserID,
                        CardID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )

    return PaginatedResponse(
        success=True,
        message="Transactions retrieved successfully",
        data={"transactions": transaction_list},
        page=page,
        per_page=per_page,
        total_items=total_items,
        total_pages=total_pages,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/transactions/users.py
<DOCUMENT>
from sqlalchemy.orm import Session
from sqlalchemy import or_, asc, desc, union_all, literal, select
from app.models.transfer import Transfer
from app.models.deposit import Deposit
from app.models.withdrawal import Withdrawal
from app.schemas.transfer_schema import TransferResponse
from app.schemas.deposit_schema import DepositResponse
from app.schemas.withdrawal_schema import WithdrawalResponse
from app.core.responses import success_response
from app.core.schemas import PaginatedResponse
from app.core.exceptions import CustomHTTPException
from fastapi import status
from datetime import date
from typing import Optional


def get_user_transactions(
    user_id: int,
    db: Session,
    page: int = 1,
    per_page: int = 10,
    transaction_type: Optional[str] = None,
    transaction_status: Optional[str] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    sort_by: Optional[str] = "Timestamp",
    order: Optional[str] = "desc",
):
    if transaction_type:
        if transaction_type not in ["Transfer", "Deposit", "Withdrawal"]:
            raise CustomHTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                message="Invalid transaction type",
            )
        # Select the appropriate model based on transaction_type
        model = {"Transfer": Transfer, "Deposit": Deposit, "Withdrawal": Withdrawal}[
            transaction_type
        ]
        if transaction_type == "Transfer":
            query = db.query(Transfer).filter(
                or_(Transfer.SenderID == user_id, Transfer.ReceiverID == user_id)
            )
        elif transaction_type == "Deposit":
            query = db.query(Deposit).filter(Deposit.UserID == user_id)
        elif transaction_type == "Withdrawal":
            query = db.query(Withdrawal).filter(Withdrawal.UserID == user_id)

        if transaction_status:
            if transaction_status not in ["Pending", "Completed", "Failed"]:
                raise CustomHTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST, message="Invalid status"
                )
            query = query.filter_by(Status=transaction_status)

        if start_date and end_date:
            if start_date > end_date:
                raise CustomHTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    message="start_date must be before end_date",
                )
            query = query.filter(
                model.Timestamp.between(start_date, end_date)
            )  # Use dynamic model
        elif start_date:
            query = query.filter(model.Timestamp >= start_date)
        elif end_date:
            query = query.filter(model.Timestamp <= end_date)

        total_items = query.count()
    else:
        transfer_query = (
            db.query(Transfer)
            .filter(or_(Transfer.SenderID == user_id, Transfer.ReceiverID == user_id))
            .add_columns(
                Transfer.TransferID.label("ID"),
                Transfer.SenderID.label("UserID"),
                Transfer.ReceiverID.label("RelatedUserID"),
                Transfer.Amount.label("Amount"),
                literal("Transfer").label("TransactionType"),
                Transfer.ReferenceNumber.label("ReferenceNumber"),
                Transfer.Status.label("Status"),
                Transfer.Description.label("Description"),
                Transfer.Timestamp.label("Timestamp"),
            )
        )
        deposit_query = (
            db.query(Deposit)
            .filter(Deposit.UserID == user_id)
            .add_columns(
                Deposit.DepositID.label("ID"),
                Deposit.UserID.label("UserID"),
                Deposit.AdminID.label("RelatedUserID"),
                Deposit.Amount.label("Amount"),
                literal("Deposit").label("TransactionType"),
                Deposit.ReferenceNumber.label("ReferenceNumber"),
                Deposit.Status.label("Status"),
                Deposit.Description.label("Description"),
                Deposit.Timestamp.label("Timestamp"),
            )
        )
        withdrawal_query = (
            db.query(Withdrawal)
            .filter(Withdrawal.UserID == user_id)
            .add_columns(
                Withdrawal.WithdrawalID.label("ID"),
                Withdrawal.UserID.label("UserID"),
                Withdrawal.CardID.label("RelatedUserID"),
                Withdrawal.Amount.label("Amount"),
                literal("Withdrawal").label("TransactionType"),
                Withdrawal.ReferenceNumber.label("ReferenceNumber"),
                Withdrawal.Status.label("Status"),
                Withdrawal.Description.label("Description"),
                Withdrawal.Timestamp.label("Timestamp"),
            )
        )
        union_query = union_all(transfer_query, deposit_query, withdrawal_query)

        # Wrap union_all in a subquery
        subquery = union_query.subquery()
        query = db.query(subquery)

        if transaction_status:
            if transaction_status not in ["Pending", "Completed", "Failed"]:
                raise CustomHTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST, message="Invalid status"
                )
            query = query.filter(subquery.c.Status == transaction_status)

        if start_date and end_date:
            if start_date > end_date:
                raise CustomHTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    message="start_date must be before end_date",
                )
            query = query.filter(subquery.c.Timestamp.between(start_date, end_date))
        elif start_date:
            query = query.filter(subquery.c.Timestamp >= start_date)
        elif end_date:
            query = query.filter(subquery.c.Timestamp <= end_date)

        total_items = query.count()

    sort_column = {"Timestamp": "Timestamp", "Amount": "Amount"}.get(
        sort_by, "Timestamp"
    )
    order_func = desc if order.lower() == "desc" else asc
    if transaction_type:
        # For single-table queries, use the correct model's columns
        sort_attr = getattr(model, sort_column)  # Use dynamic model
        query = query.order_by(order_func(sort_attr))
    else:
        # For union_all, use subquery column names
        query = query.order_by(order_func(subquery.c[sort_column]))

    offset = (page - 1) * per_page
    transactions = query.offset(offset).limit(per_page).all()

    if not transactions:
        return PaginatedResponse(
            success=True,
            message="No transactions found",
            data={"transactions": []},
            page=page,
            per_page=per_page,
            total_items=0,
            total_pages=0,
        )

    total_pages = (total_items + per_page - 1) // per_page

    transaction_list = []
    if transaction_type:
        # Single-table response
        if transaction_type == "Transfer":
            transaction_list = [
                TransferResponse.model_validate(t).model_dump() for t in transactions
            ]
        elif transaction_type == "Deposit":
            transaction_list = [
                DepositResponse.model_validate(t).model_dump() for t in transactions
            ]
        elif transaction_type == "Withdrawal":
            transaction_list = [
                WithdrawalResponse.model_validate(t).model_dump() for t in transactions
            ]
    else:
        # Union_all response
        for t in transactions:
            if t.TransactionType == "Transfer":
                transaction_list.append(
                    TransferResponse(
                        TransferID=t.ID,
                        SenderID=t.UserID,
                        ReceiverID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )
            elif t.TransactionType == "Deposit":
                transaction_list.append(
                    DepositResponse(
                        DepositID=t.ID,
                        UserID=t.UserID,
                        AdminID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )
            elif t.TransactionType == "Withdrawal":
                transaction_list.append(
                    WithdrawalResponse(
                        WithdrawalID=t.ID,
                        UserID=t.UserID,
                        CardID=t.RelatedUserID,
                        Amount=float(t.Amount),
                        ReferenceNumber=t.ReferenceNumber,
                        Status=t.Status,
                        Description=t.Description,
                        Timestamp=t.Timestamp,
                    ).model_dump()
                )

    return PaginatedResponse(
        success=True,
        message="Transactions retrieved successfully",
        data={"transactions": transaction_list},
        page=page,
        per_page=per_page,
        total_items=total_items,
        total_pages=total_pages,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/transfers/users.py
<DOCUMENT>
from fastapi import status, BackgroundTasks
from sqlalchemy.orm import Session
from decimal import Decimal
from app.models.transfer import Transfer
from app.models.user import User
from app.schemas.transfer_schema import TransferCreate, TransferResponse
from app.core.responses import success_response
from app.core.exceptions import CustomHTTPException
from app.core.event_emitter import emit_event
import uuid


async def create_transfer(sender_id: int, transfer: TransferCreate, db: Session,background_tasks:BackgroundTasks):
    sender = db.query(User).filter(User.UserID == sender_id).with_for_update().first()
    if not sender:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Sender not found"
        )
    if not sender.IsActive:
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN, message="Sender account is inactive"
        )

    amount = Decimal(str(transfer.Amount))
    if amount <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Amount must be positive"
        )
    if sender.Balance < amount:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Insufficient balance"
        )

    receiver = (
        db.query(User)
        .filter(User.UserID == transfer.ReceiverID)
        .with_for_update()
        .first()
    )
    if not receiver:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Receiver not found"
        )
    if sender_id == transfer.ReceiverID:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Cannot transfer money to yourself",
        )
    if not receiver.IsActive:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Receiver account is inactive",
        )

    new_transfer = Transfer(
        SenderID=sender_id,
        ReceiverID=transfer.ReceiverID,
        Amount=amount,
        ReferenceNumber=str(uuid.uuid4()),
        Status="Pending",
        Description=transfer.Description,
    )

    try:
        sender.Balance -= amount
        receiver.Balance += amount
        new_transfer.Status = "Completed"
        db.add(new_transfer)
        db.commit()
        db.refresh(new_transfer)

        # Emit notification to sender
        await emit_event(
            "money_sent",
            {
                "transfer_id": new_transfer.TransferID,
                "amount": float(amount),
                "receiver_id": receiver.UserID,
                "balance": float(sender.Balance),
                "reference": new_transfer.ReferenceNumber,
                "timestamp": str(new_transfer.Timestamp)
            },
            user_id=sender_id,
            background_tasks=background_tasks
        )

        # Emit notification to receiver
        await emit_event(
            "money_received",
            {
                "transfer_id": new_transfer.TransferID,
                "amount": float(amount),
                "sender_id": sender_id,
                "balance": float(receiver.Balance),
                "reference": new_transfer.ReferenceNumber,
                "timestamp": str(new_transfer.Timestamp)
            },
            user_id=receiver.UserID,
            background_tasks=background_tasks
        )

        return success_response(
            message="Transfer completed successfully",
            data=TransferResponse.model_validate(new_transfer).model_dump(),
        )
    except Exception as e:
        db.rollback()
        new_transfer.Status = "Failed"
        db.commit()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Transfer failed",
            details={"error": str(e)},
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/controllers/withdrawals/atm.py
<DOCUMENT>
from datetime import date
from sqlalchemy import func
from sqlalchemy.orm import Session
from decimal import Decimal
from app.models.withdrawal import Withdrawal
from app.models.card import Card
from app.models.user import User
from app.schemas.withdrawal_schema import WithdrawalCreate, WithdrawalResponse
from app.core.responses import success_response
from app.core.exceptions import CustomHTTPException
from app.core.auth import pwd_context
from fastapi import status
import uuid
from fastapi import BackgroundTasks
from app.core.event_emitter import emit_event


async def create_withdrawal(
    withdrawal: WithdrawalCreate, 
    db: Session,
    background_tasks: BackgroundTasks
):
    card = (
        db.query(Card)
        .filter(Card.CardNumber == withdrawal.CardNumber)
        .with_for_update()
        .first()
    )
    if not card:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="Card not found"
        )
    if card.Status != "Active":
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Card is not active"
        )
    if card.ExpirationDate < date.today():
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Card has expired"
        )

    if not pwd_context.verify(withdrawal.Pin, card.Pin):
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, message="Invalid PIN"
        )

    user = db.query(User).filter(User.UserID == card.UserID).with_for_update().first()
    if not user:
        raise CustomHTTPException(
            status_code=status.HTTP_404_NOT_FOUND, message="User not found"
        )
    if not user.IsActive:
        raise CustomHTTPException(
            status_code=status.HTTP_403_FORBIDDEN, message="User account is inactive"
        )

    amount = Decimal(str(withdrawal.Amount))
    if amount <= 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Withdrawal amount must be positive",
        )
    if user.Balance < amount:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, message="Insufficient balance"
        )

    new_withdrawal = Withdrawal(
        UserID=card.UserID,
        CardID=card.CardID,
        Amount=amount,
        ReferenceNumber=str(uuid.uuid4()),
        Status="Pending",
        Description="ATM withdrawal",
    )

    try:
        user.Balance -= amount
        new_withdrawal.Status = "Completed"
        db.add(new_withdrawal)
        db.commit()
        db.refresh(new_withdrawal)

        # Emit real-time notification
        await emit_event(
            "atm_withdrawal_completed",
            {
                "withdrawal_id": new_withdrawal.WithdrawalID,
                "amount": float(amount),
                "balance": float(user.Balance),
                "reference": new_withdrawal.ReferenceNumber,
                "timestamp": str(new_withdrawal.Timestamp)
            },
            user_id=user.UserID,
            background_tasks=background_tasks
        )

        return success_response(
            message="Withdrawal completed successfully",
            data=WithdrawalResponse.model_validate(new_withdrawal).model_dump(),
        )
    except Exception as e:
        db.rollback()
        new_withdrawal.Status = "Failed"
        db.commit()
        raise CustomHTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            message="Withdrawal failed",
            details={"error": str(e)},
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/auth.py
<DOCUMENT>
from fastapi import Depends, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.models.user import User
from app.models.admin import Admin
from datetime import datetime, timedelta, timezone
from passlib.context import CryptContext
from app.core.exceptions import CustomHTTPException
from app.core.responses import success_response, error_response
import os
import uuid

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 7))

if not SECRET_KEY:
    raise ValueError("SECRET_KEY must be set in the .env file")

user_oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/users/login")
admin_oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/admins/login")
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire, "role_id": data.get("role_id")})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def create_refresh_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update(
        {"exp": expire, "jti": str(uuid.uuid4()), "role_id": data.get("role_id")}
    )
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def get_current_user(
    token: str = Depends(user_oauth2_scheme), db: Session = Depends(get_db)
):
    credentials_exception = CustomHTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        message="Could not validate credentials",
        details={},
    )
    if not isinstance(token, str):
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            message=f"Invalid token type: expected string, got {type(token)}",
            details={"token": token},
        )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        user_id = int(user_id)
    except JWTError as e:
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            message="Invalid or expired token",
            details={"error": str(e)},
        )
    except ValueError:
        raise credentials_exception

    user = db.query(User).filter(User.UserID == user_id).first()
    if user is None:
        raise credentials_exception

    return user


def get_current_admin(
    token: str = Depends(admin_oauth2_scheme), db: Session = Depends(get_db)
):
    credentials_exception = CustomHTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        message="Could not validate credentials",
        details={},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        admin_id: str = payload.get("sub")
        role_id: int = payload.get("role_id")
        if admin_id is None or role_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    admin = db.query(Admin).filter(Admin.AdminID == int(admin_id)).first()
    if admin is None or admin.RoleID != role_id:
        raise credentials_exception
    return admin


def refresh_token(refresh_token: str, db: Session, model, role: str, id_field: str):
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        entity_id: str = payload.get("sub")
        role_id: int = payload.get("role_id")
        if entity_id is None or role_id is None:
            raise CustomHTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message="Invalid refresh token",
                details={},
            )

        entity = (
            db.query(model).filter(getattr(model, id_field) == int(entity_id)).first()
        )
        if not entity:
            raise CustomHTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                message=f"{role} not found",
                details={},
            )

        new_access_token = create_access_token(
            data={"sub": str(entity_id), "role_id": role_id}
        )
        new_refresh_token = create_refresh_token(
            data={"sub": str(entity_id), "role_id": role_id}
        )
        return success_response(
            message="Token refreshed successfully",
            data={
                "access_token": new_access_token,
                "refresh_token": new_refresh_token,
                "token_type": "bearer",
            },
        )
    except JWTError:
        raise CustomHTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            message="Invalid or expired refresh token",
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/database.py
<DOCUMENT>
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Load environment variables
load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL is not set in the .env file!")

# Database connection with pooling
engine = create_engine(
    DATABASE_URL,
    pool_size=5,  # Max connections in pool
    max_overflow=10,  # Extra connections if needed
    pool_timeout=30,  # Wait time for a connection
    pool_recycle=1800,  # Recycle connections every 30 minutes
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


# Dependency to get the DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/event_emitter.py
<DOCUMENT>
from app.core.websocket_manager import ConnectionManager
from typing import Optional
from datetime import datetime, timezone
from app.core.websocket_manager import ConnectionManager
from fastapi import BackgroundTasks

manager = ConnectionManager()

async def emit_event(
    event_type: str,
    data: dict,
    user_id: Optional[int] = None,
    admin_id: Optional[int] = None,
    broadcast: bool = False,
    background_tasks: Optional[BackgroundTasks] = None
):
    message = {
        "type": event_type,
        "data": data,
        "timestamp": str(datetime.now(timezone.utc))
    }
    
    print(f"Emitting event: {event_type} to user_id: {user_id}, admin_id: {admin_id}, broadcast: {broadcast}")  # Debug log
    
    async def send_notification():
        try:
            if broadcast:
                await manager.broadcast(message)
            elif user_id:
                await manager.send_personal_message(message, user_id, "user")
            elif admin_id:
                await manager.send_personal_message(message, admin_id, "admin")
            print(f"Event {event_type} sent successfully")  # Debug log
        except Exception as e:
            print(f"Failed to emit event {event_type}: {str(e)}")  # Error log

    if background_tasks:
        background_tasks.add_task(send_notification)
    else:
        await send_notification()
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/exceptions.py
<DOCUMENT>
from typing import Any, Dict, Optional
from fastapi import HTTPException, status
from .responses import error_response


class CustomHTTPException(HTTPException):
    def __init__(
        self, status_code: int, message: str, details: Optional[Dict[str, Any]] = None
    ):
        super().__init__(
            status_code=status_code,
            detail=error_response(message, status_code, details),
        )


class DatabaseError(CustomHTTPException):
    def __init__(self, message: str):
        super().__init__(status.HTTP_500_INTERNAL_SERVER_ERROR, message)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/rate_limiter.py
<DOCUMENT>
from datetime import date, datetime
from decimal import Decimal
from slowapi import Limiter
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import Request, HTTPException
from app.core.auth import get_current_user, get_current_admin
from app.models.user import User
from app.models.admin import Admin
import os
from redis import Redis
from typing import Optional, Any
import json

# Singleton Redis client
redis_client = None

# Load cache TTLs from environment with defaults
CACHE_TTL_SHORT = int(
    os.getenv("REDIS_CACHE_TTL_SHORT", "300")
)  # 5 min for volatile data
CACHE_TTL_MEDIUM = int(
    os.getenv("REDIS_CACHE_TTL_MEDIUM", "3600")
)  # 1 hr for semi-static
CACHE_TTL_LONG = int(os.getenv("REDIS_CACHE_TTL_LONG", "86400"))  # 24 hr for static


def get_redis_client() -> Redis:
    global redis_client
    if redis_client is None:
        redis_client = Redis.from_url(
            os.getenv("REDIS_URL", "redis://localhost:6379/0"),
            decode_responses=True,
        )
    return redis_client


# Custom key function for rate limiting
def get_rate_limit_key(request: Request) -> str:
    auth_header = request.headers.get("Authorization")
    if request.url.path.startswith("/api/v1/users") and auth_header:
        try:
            token = auth_header.split("Bearer ")[1]
            user: User = get_current_user(token, request.state.db)
            return f"user:{user.UserID}"
        except (IndexError, AttributeError, HTTPException):
            pass
    elif request.url.path.startswith("/api/v1/admins") and auth_header:
        try:
            token = auth_header.split("Bearer ")[1]
            admin: Admin = get_current_admin(token, request.state.db)
            return f"admin:{admin.AdminID}"
        except (IndexError, AttributeError, HTTPException):
            pass
    return f"ip:{get_remote_address(request)}"


limiter = Limiter(
    key_func=get_rate_limit_key,
    storage_uri=os.getenv("REDIS_URL", "redis://localhost:6379/0"),
    default_limits=["100/hour"],
    enabled=True,
)


async def custom_rate_limit_handler(request: Request, exc: RateLimitExceeded):
    key = get_rate_limit_key(request)
    redis = get_redis_client()
    ttl = redis.ttl(f"{key}:rate_limit") or 60
    raise HTTPException(
        status_code=429,
        detail={
            "success": False,
            "message": "Too many requests. Please try again later.",
            "data": {"retry_after": ttl},
        },
        headers={"Retry-After": str(ttl)},
    )


def get_limiter() -> Limiter:
    return limiter


# Caching Utilities
def get_cache_key(
    request: Request, endpoint: str, user_id: Optional[int] = None, params: dict = None
) -> str:
    """Generate a unique cache key based on endpoint, user, and query params."""
    base = f"{endpoint}"
    if user_id:
        base += f":user:{user_id}"
    if params:
        param_str = ":".join(
            f"{k}={v}" for k, v in sorted(params.items()) if v is not None
        )
        base += f":{param_str}"
    return base


def get_from_cache(key: str) -> Optional[Any]:
    """Retrieve data from Redis cache."""
    redis = get_redis_client()
    cached = redis.get(key)
    return json.loads(cached) if cached else None


class DateTimeEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        if isinstance(obj, date):
            return obj.isoformat()
        if isinstance(obj, Decimal):
            return float(obj)
        return super().default(obj)


def set_to_cache(key: str, value: Any, ttl: int) -> None:
    """Store data in Redis cache with specified TTL."""
    redis = get_redis_client()
    redis.setex(key, ttl, json.dumps(value, cls=DateTimeEncoder))


def invalidate_cache(pattern: str) -> None:
    """Invalidate cache keys matching a pattern (e.g., 'users:*')."""
    redis = get_redis_client()
    keys = redis.keys(f"{pattern}*")
    if keys:
        redis.delete(*keys)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/rbac.py
<DOCUMENT>
from fastapi import Depends, status
from sqlalchemy.orm import Session
from app.core.exceptions import CustomHTTPException
from app.core.auth import get_current_admin
from app.core.database import get_db
from app.models.admin import Admin
from app.models.rbac import Role, RolePermission, Permission


def check_permission(permission: str):
    def permission_checker(
        current_admin: Admin = Depends(get_current_admin), db: Session = Depends(get_db)
    ):
        # Fetch the role and its permissions
        role_permissions = (
            db.query(Permission.PermissionName)
            .join(
                RolePermission, RolePermission.PermissionID == Permission.PermissionID
            )
            .join(Role, Role.RoleID == RolePermission.RoleID)
            .filter(Role.RoleID == current_admin.RoleID)
            .all()
        )

        # Extract permission names as a list
        permissions = [rp.PermissionName for rp in role_permissions]

        if permission not in permissions:
            role_name = (
                db.query(Role.RoleName)
                .filter(Role.RoleID == current_admin.RoleID)
                .scalar()
            )
            raise CustomHTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                message=f"Permission '{permission}' denied for role '{role_name}'",
                details={},
            )
        return current_admin

    return permission_checker


def get_role_permissions(role_id: int, db: Session) -> set[str]:
    permissions = (
        db.query(Permission.PermissionName)
        .join(RolePermission, RolePermission.PermissionID == Permission.PermissionID)
        .filter(RolePermission.RoleID == role_id)
        .all()
    )
    return {p.PermissionName for p in permissions}


def has_permissions(role_id: int, required_permissions: list[str], db: Session) -> bool:
    role_permissions = get_role_permissions(role_id, db)
    return all(perm in role_permissions for perm in required_permissions)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/responses.py
<DOCUMENT>
from fastapi import status
from typing import Any, Dict, Optional
from .schemas import BaseResponse


def success_response(
    message: str,
    data: Optional[Dict[str, Any]] = None,
    status_code: int = status.HTTP_200_OK,
) -> Dict[str, Any]:
    return BaseResponse(
        success=True,
        message=message,
        data=data,
    ).model_dump()


def error_response(
    message: str,
    status_code: int = status.HTTP_400_BAD_REQUEST,
    details: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    return BaseResponse(
        success=False,
        message=message,
        data=details or {},
    ).model_dump()
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/schemas.py
<DOCUMENT>
from pydantic import BaseModel, ConfigDict
from typing import TypeVar, Optional, Dict, Any
from datetime import datetime, date

T = TypeVar("T")


class BaseResponse(BaseModel):
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    model_config = ConfigDict(
        json_encoders={
            datetime: lambda v: v.isoformat(),
            date: lambda v: v.strftime("%Y-%m-%d"),
        },
        from_attributes=True,
    )


class PaginatedResponse(BaseResponse):
    page: int
    per_page: int
    total_items: int
    total_pages: int

    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={
            datetime: lambda v: v.isoformat(),
            date: lambda v: v.isoformat(),
        },
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/utils.py
<DOCUMENT>
# app/core/utils.py
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from app.core.exceptions import CustomHTTPException
from typing import TypeVar, Type

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

T = TypeVar("T")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)


def check_unique_field(
    db: Session,
    model: Type[T],
    field_name: str,
    value: any,
    exclude_id: int | None = None,
) -> None:
    query = db.query(model).filter(getattr(model, field_name) == value)
    if exclude_id:
        query = query.filter(getattr(model, "id") != exclude_id)
    if query.first():
        raise CustomHTTPException(
            status_code=400, message=f"{field_name} {value} already exists"
        )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/core/websocket_manager.py
<DOCUMENT>
from typing import Dict, Set
from fastapi import WebSocket
from app.core.auth import jwt, SECRET_KEY, ALGORITHM
import json
from app.core.rate_limiter import get_redis_client
from datetime import datetime, timezone


class ConnectionManager:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.active_connections = {"user": {}, "admin": {}}
        return cls._instance

    async def connect(self, websocket: WebSocket, token: str, connection_type: str):
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            entity_id = int(payload.get("sub"))

            await websocket.accept()

            if connection_type not in self.active_connections:
                self.active_connections[connection_type] = {}

            if entity_id not in self.active_connections[connection_type]:
                self.active_connections[connection_type][entity_id] = set()

            self.active_connections[connection_type][entity_id].add(websocket)
            print(f"Added {connection_type} {entity_id} to active connections")
            print(f"Current connections state: {self.active_connections}")

            await websocket.send_json(
                {
                    "type": "connection_status",
                    "data": {"status": "connected", "entity_id": entity_id},
                    "timestamp": str(datetime.now(timezone.utc)),
                }
            )

            return entity_id
        except Exception as e:
            print(f"Connection error: {str(e)}")
            if not websocket.client_state.disconnected:
                await websocket.close(code=4001)
            return None

    async def send_personal_message(
        self, message: dict, entity_id: int, connection_type: str
    ):
        print(f"Attempting to send message to {connection_type} {entity_id}")
        print(f"Current connections state: {self.active_connections}")

        try:
            if (
                connection_type in self.active_connections
                and entity_id in self.active_connections[connection_type]
            ):
                connections = self.active_connections[connection_type][entity_id]
                dead_connections = set()

                for connection in connections:
                    try:
                        await connection.send_json(message)
                        print(
                            f"Successfully sent message to {connection_type} {entity_id}"
                        )
                    except Exception as e:
                        print(f"Error sending to connection: {str(e)}")
                        dead_connections.add(connection)

                # Remove dead connections
                for dead in dead_connections:
                    connections.remove(dead)
                    print(f"Removed dead connection for {connection_type} {entity_id}")
            else:
                print(f"No active connections found for {connection_type} {entity_id}")
        except Exception as e:
            print(f"Error in send_personal_message: {str(e)}")

    async def broadcast(self, message: dict):
        print(f"Broadcasting message: {message}")  # Debug log
        for connection_type in self.active_connections:
            for entity_id, connections in self.active_connections[
                connection_type
            ].items():
                for (
                    connection
                ) in (
                    connections.copy()
                ):  # Use copy to avoid modification during iteration
                    try:
                        await connection.send_json(message)
                        print(f"Broadcast successful to {connection_type} {entity_id}")
                    except Exception as e:
                        print(
                            f"Broadcast error to {connection_type} {entity_id}: {str(e)}"
                        )
                        connections.remove(connection)

    async def publish_event(self, event_type: str, data: dict):
        message = {
            "type": event_type,
            "data": data,
            "timestamp": str(datetime.now(timezone.utc)),
        }
        await self.redis.publish("banking_events", json.dumps(message))

    async def disconnect(
        self, websocket: WebSocket, entity_id: int, connection_type: str
    ):
        """Disconnect a WebSocket connection and remove it from active connections."""
        try:
            if (
                connection_type in self.active_connections
                and entity_id in self.active_connections[connection_type]
            ):
                self.active_connections[connection_type][entity_id].remove(websocket)
                print(f"Removed {connection_type} {entity_id} from active connections")
                print(f"Current connections state: {self.active_connections}")

                # Clean up empty sets
                if not self.active_connections[connection_type][entity_id]:
                    del self.active_connections[connection_type][entity_id]
        except Exception as e:
            print(f"Error in disconnect: {str(e)}")
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/admin.py
<DOCUMENT>
from sqlalchemy import Column, ForeignKey, Integer, String, DateTime
from sqlalchemy.sql import func
from app.core.database import Base


class Admin(Base):
    __tablename__ = "Admins"

    AdminID = Column(Integer, primary_key=True, index=True)
    Username = Column(String(50), unique=True, nullable=False)
    Password = Column(String(255), nullable=False)
    Email = Column(String(100), unique=True, nullable=False, index=True)
    RoleID = Column(Integer, ForeignKey("Roles.RoleID"), nullable=False)
    CreatedAt = Column(DateTime, server_default=func.now())
    LastLogin = Column(DateTime, nullable=True)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/card.py
<DOCUMENT>
from sqlalchemy import Column, DateTime, Integer, String, Date, ForeignKey
from sqlalchemy.sql import func
from app.core.database import Base


class Card(Base):
    __tablename__ = "Cards"

    CardID = Column(Integer, primary_key=True, index=True)
    UserID = Column(
        Integer, ForeignKey("Users.UserID", ondelete="CASCADE"), nullable=False
    )
    CardNumber = Column(String(16), unique=True, nullable=False)
    Pin = Column(String(255), nullable=False)
    ExpirationDate = Column(Date, nullable=False)
    Status = Column(String(20), nullable=False, default="Active")
    CreatedAt = Column(DateTime, server_default=func.now())
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/deposit.py
<DOCUMENT>
from sqlalchemy import Column, Integer, String, DateTime, DECIMAL, ForeignKey
from sqlalchemy.sql import func
from app.core.database import Base


class Deposit(Base):
    __tablename__ = "Deposits"

    DepositID = Column(Integer, primary_key=True, index=True)
    UserID = Column(Integer, ForeignKey("Users.UserID"), nullable=False)
    AdminID = Column(Integer, ForeignKey("Admins.AdminID"), nullable=False)
    Amount = Column(DECIMAL(19, 4), nullable=False)
    ReferenceNumber = Column(String(50), nullable=False)
    Status = Column(String(20), nullable=False, default="Pending")
    Description = Column(String(255), nullable=True)
    Timestamp = Column(DateTime, server_default=func.now())
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/loan.py
<DOCUMENT>
from sqlalchemy import (
    CheckConstraint,
    Column,
    Integer,
    String,
    DateTime,
    DECIMAL,
    ForeignKey,
    Date,
    Computed,
)
from sqlalchemy.sql import func, text
from app.core.database import Base


class LoanType(Base):
    __tablename__ = "LoanTypes"

    LoanTypeID = Column(Integer, primary_key=True, index=True)
    LoanTypeName = Column(String(50), unique=True, nullable=False)
    DefaultInterestRate = Column(
        DECIMAL(5, 2), CheckConstraint("DefaultInterestRate > 0"), nullable=False
    )
    LatePaymentFeePerDay = Column(
        DECIMAL(10, 2), CheckConstraint("LatePaymentFeePerDay >= 0"), nullable=False
    )


class Loan(Base):
    __tablename__ = "Loans"

    LoanID = Column(Integer, primary_key=True, index=True)
    UserID = Column(Integer, ForeignKey("Users.UserID", ondelete="CASCADE"))
    LoanTypeID = Column(Integer, ForeignKey("LoanTypes.LoanTypeID", ondelete="CASCADE"))
    LoanAmount = Column(
        DECIMAL(19, 4), CheckConstraint("LoanAmount > 0"), nullable=False
    )
    InterestRate = Column(DECIMAL(5, 2), nullable=False)
    LoanDurationMonths = Column(
        Integer, CheckConstraint("LoanDurationMonths > 0"), nullable=False
    )
    MonthlyInstallment = Column(
        DECIMAL(19, 4),
        Computed(
            "(LoanAmount * (InterestRate/100.0/12) * POWER(1 + (InterestRate/100.0/12), LoanDurationMonths)) / "
            "(POWER(1 + (InterestRate/100.0/12), LoanDurationMonths) - 1)"
        ),
        nullable=False,
    )
    DueDate = Column(Date, nullable=False)
    LoanStatus = Column(
        String(20),
        CheckConstraint("LoanStatus IN ('Pending', 'Approved', 'Rejected', 'Repaid')"),
        server_default="Pending",
    )
    CreatedAt = Column(DateTime, server_default=func.now())


class LoanPayment(Base):
    __tablename__ = "LoanPayments"

    PaymentID = Column(Integer, primary_key=True, index=True)
    LoanID = Column(Integer, ForeignKey("Loans.LoanID", ondelete="CASCADE"))
    PaymentAmount = Column(
        DECIMAL(19, 4), CheckConstraint("PaymentAmount > 0"), nullable=False
    )
    PaymentDate = Column(Date, server_default=text("GETDATE()"))
    LateFee = Column(DECIMAL(10, 2), server_default=text("0"))
    TotalAmountPaid = Column(
        DECIMAL(19, 4), Computed("PaymentAmount + LateFee"), nullable=False
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/rbac.py
<DOCUMENT>
from sqlalchemy import Column, Integer, String, ForeignKey
from app.core.database import Base


class Role(Base):
    __tablename__ = "Roles"

    RoleID = Column(Integer, primary_key=True, index=True)
    RoleName = Column(String(50), unique=True, nullable=False)
    Description = Column(String(255), nullable=True)


class Permission(Base):
    __tablename__ = "Permissions"

    PermissionID = Column(Integer, primary_key=True, index=True)
    PermissionName = Column(String(100), unique=True, nullable=False)
    Description = Column(String(255), nullable=True)


class RolePermission(Base):
    __tablename__ = "RolePermissions"

    RolePermissionID = Column(Integer, primary_key=True, index=True)
    RoleID = Column(
        Integer, ForeignKey("Roles.RoleID", ondelete="CASCADE"), nullable=False
    )
    PermissionID = Column(
        Integer,
        ForeignKey("Permissions.PermissionID", ondelete="CASCADE"),
        nullable=False,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/transfer.py
<DOCUMENT>
from sqlalchemy import Column, Integer, String, DateTime, DECIMAL, ForeignKey
from sqlalchemy.sql import func
from app.core.database import Base


class Transfer(Base):
    __tablename__ = "Transfers"

    TransferID = Column(Integer, primary_key=True, index=True)
    SenderID = Column(Integer, ForeignKey("Users.UserID"), nullable=False)
    ReceiverID = Column(Integer, ForeignKey("Users.UserID"), nullable=False)
    Amount = Column(DECIMAL(19, 4), nullable=False)
    ReferenceNumber = Column(String(50), nullable=False)
    Status = Column(String(20), nullable=False, default="Pending")
    Description = Column(String(255), nullable=True)
    Timestamp = Column(DateTime, server_default=func.now())
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/user.py
<DOCUMENT>
from sqlalchemy import (
    CheckConstraint,
    Column,
    ForeignKey,
    Integer,
    String,
    DateTime,
    Boolean,
    DECIMAL,
    Date,
)
from sqlalchemy.sql import func, text
from app.core.database import Base


class User(Base):
    __tablename__ = "Users"

    UserID = Column(Integer, primary_key=True, index=True)
    Username = Column(String(50), unique=True, nullable=False)
    FirstName = Column(String(50), nullable=False, server_default="")
    LastName = Column(String(50), nullable=False, server_default="")
    StreetAddress = Column(String(255), nullable=True)
    City = Column(String(50), nullable=True)
    State = Column(String(50), nullable=True)
    Country = Column(String(50), nullable=True)
    PostalCode = Column(String(20), nullable=True)
    PhoneNumber = Column(String(20), nullable=True)
    CNIC = Column(
        String(15),
        CheckConstraint(
            "CNIC LIKE '[0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9]'"
        ),
        unique=True,
        nullable=False,
    )
    Email = Column(String(100), unique=True, nullable=False)
    Password = Column(String(255), nullable=False)
    AccountType = Column(
        String(10),
        CheckConstraint("AccountType IN ('Savings', 'Current')"),
        nullable=False,
    )
    Balance = Column(DECIMAL(19, 4), server_default=text("0.0000"))
    DateOfBirth = Column(Date, nullable=False)
    IsActive = Column(Boolean, default=False)
    CreatedAt = Column(DateTime, server_default=func.now())
    LastLogin = Column(DateTime, nullable=True)
    ApprovedByAdminID = Column(Integer, ForeignKey("Admins.AdminID"), nullable=True)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/models/withdrawal.py
<DOCUMENT>
from sqlalchemy import Column, Integer, String, DateTime, DECIMAL, ForeignKey
from sqlalchemy.sql import func
from app.core.database import Base


class Withdrawal(Base):
    __tablename__ = "Withdrawals"

    WithdrawalID = Column(Integer, primary_key=True, index=True)
    UserID = Column(Integer, ForeignKey("Users.UserID"), nullable=False)
    CardID = Column(Integer, ForeignKey("Cards.CardID"), nullable=False)
    Amount = Column(DECIMAL(19, 4), nullable=False)
    ReferenceNumber = Column(String(50), nullable=False)
    Status = Column(String(20), nullable=False, default="Pending")
    Description = Column(String(255), nullable=True)
    Timestamp = Column(DateTime, server_default=func.now())
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/routes/admins.py
<DOCUMENT>
# app/routes/admins.py
from datetime import date, datetime
from typing import Optional
from fastapi import APIRouter, Depends, Query, Request
from sqlalchemy.orm import Session
from app.core.rate_limiter import (
    limiter,
    get_redis_client,
    CACHE_TTL_SHORT,
    CACHE_TTL_MEDIUM,
    get_cache_key,
    get_from_cache,
    set_to_cache,
    invalidate_cache,
)
from fastapi import BackgroundTasks
import json

# Controllers
from app.controllers.admin_controller import (
    delete_user,
    export_transactions,
    get_all_admins,
    register_admin,
    login_admin,
    toggle_user_active_status,
    update_user,
    get_analytics_summary,
    get_current_admin,
    update_current_admin,
    update_admin_password,
    get_admin_by_id,
    delete_admin,
    get_user_by_id,
    get_user_deposits,
    get_loan_by_id,
    get_card_by_id,
    unblock_card,
    get_transaction_by_id,
    get_all_users,
)
from app.controllers.deposits.admins import create_deposit
from app.controllers.transactions.admins import get_all_transactions
from app.controllers.loans.admins import approve_loan, reject_loan, get_all_loans
from app.controllers.cards.admins import list_all_cards, block_card, update_card_admin

# Schemas
from app.core.exceptions import CustomHTTPException
from app.schemas.admin_schema import (
    AdminCreate,
    AdminLogin,
    AdminOrder,
    AdminPasswordUpdate,
    AdminSortBy,
    AdminUpdate,
)
from app.schemas.card_schema import CardUpdate
from app.schemas.deposit_schema import DepositCreate
from app.schemas.user_schema import Order, SortBy, UserUpdate

# Core
from app.core.database import get_db
from app.core.schemas import BaseResponse, PaginatedResponse
from app.core.auth import refresh_token
from app.core.rbac import check_permission

# Models
from app.models.admin import Admin
import os
from fastapi import BackgroundTasks

router = APIRouter()


@router.post("/bootstrap_admin", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def bootstrap_admin(
    request: Request, admin: AdminCreate, db: Session = Depends(get_db)
):
    if db.query(Admin).count() > 0:
        raise CustomHTTPException(
            status_code=403, message="Admin bootstrap only allowed when no admins exist"
        )
    return register_admin(admin, db)


@router.post("/register", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def register(
    request: Request,
    admin: AdminCreate,
    current_admin: Admin = Depends(check_permission("admin:register")),
    db: Session = Depends(get_db),
):
    result = register_admin(admin, db)
    invalidate_cache("admins:")  # Invalidate admin list cache
    return result


@router.post("/login", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_LOGIN", "5/minute"))
def login(request: Request, credentials: AdminLogin, db: Session = Depends(get_db)):
    return login_admin(credentials, db)


@router.post("/refresh", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def refresh(request: Request, token: str, db: Session = Depends(get_db)):
    return refresh_token(token, db, Admin, "Admin", "AdminID")


@router.get("/me", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_current_admin_route(
    request: Request,
    current_admin: Admin = Depends(check_permission("admin:view_self")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"admin:{current_admin.AdminID}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_current_admin(current_admin.AdminID, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.put("/me", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_current_admin_route(
    request: Request,
    admin_update: AdminUpdate,
    current_admin: Admin = Depends(check_permission("admin:update_self")),
    db: Session = Depends(get_db),
):
    result = update_current_admin(current_admin.AdminID, admin_update, db)
    invalidate_cache(f"admin:{current_admin.AdminID}")
    invalidate_cache("admins:")
    return result


@router.put("/me/password", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_admin_password_route(
    request: Request,
    password_update: AdminPasswordUpdate,
    current_admin: Admin = Depends(check_permission("admin:update_self")),
    db: Session = Depends(get_db),
):
    return update_admin_password(current_admin.AdminID, password_update, db)


@router.get("/admins/{admin_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_admin_by_id_route(
    request: Request,
    admin_id: int,
    current_admin: Admin = Depends(check_permission("admin:view_all")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"admin:{admin_id}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_admin_by_id(admin_id, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.delete("/admins/{admin_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def delete_admin_route(
    request: Request,
    admin_id: int,
    current_admin: Admin = Depends(check_permission("admin:delete")),
    db: Session = Depends(get_db),
):
    result = delete_admin(admin_id, current_admin.AdminID, db)
    invalidate_cache(f"admin:{admin_id}")
    invalidate_cache("admins:")
    return result


@router.get("/users/{user_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_user_by_id_route(
    request: Request,
    user_id: int,
    current_admin: Admin = Depends(check_permission("user:view_all")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"user:{user_id}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_user_by_id(user_id, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.get("/users/{user_id}/deposits", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_user_deposits_route(
    request: Request,
    user_id: int,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    deposit_status: Optional[str] = Query(None),
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    sort_by: Optional[str] = Query("Timestamp"),
    order: Optional[str] = Query("desc"),
    current_admin: Admin = Depends(check_permission("deposit:view_all")),
    db: Session = Depends(get_db),
):
    params = {
        "page": page,
        "per_page": per_page,
        "deposit_status": deposit_status,
        "start_date": str(start_date),
        "end_date": str(end_date),
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(
        request, f"user_deposits:{user_id}", current_admin.AdminID, params
    )
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_user_deposits(
        user_id,
        db,
        page,
        per_page,
        deposit_status,
        start_date,
        end_date,
        sort_by,
        order,
    )
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.get("/loans/{loan_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_loan_by_id_route(
    request: Request,
    loan_id: int,
    current_admin: Admin = Depends(check_permission("loan:view_all")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"loan:{loan_id}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_loan_by_id(loan_id, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.put("/loans/{loan_id}/reject", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
async def reject_loan_route(
    request: Request,
    loan_id: int,
    background_tasks: BackgroundTasks,
    current_admin: Admin = Depends(check_permission("loan:approve")),
    db: Session = Depends(get_db),
):
    result = await reject_loan(loan_id, current_admin, db, background_tasks)
    invalidate_cache("loans:")
    invalidate_cache("analytics:summary")
    return result


@router.get("/cards/{card_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_card_by_id_route(
    request: Request,
    card_id: int,
    current_admin: Admin = Depends(check_permission("card:view_all")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"card:{card_id}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_card_by_id(card_id, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.put("/cards/{card_id}/unblock", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def unblock_card_route(
    request: Request,
    card_id: int,
    current_admin: Admin = Depends(check_permission("card:manage")),
    db: Session = Depends(get_db),
):
    result = unblock_card(card_id, db)
    invalidate_cache("cards:")
    return result


@router.get("/transactions/{transaction_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_transaction_by_id_route(
    request: Request,
    transaction_id: int,
    transaction_type: str = Query(...),
    current_admin: Admin = Depends(check_permission("transaction:view_all")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(
        request, f"transaction:{transaction_type}:{transaction_id}"
    )
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_transaction_by_id(transaction_id, transaction_type, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.get("/analytics/summary", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_analytics_summary_route(
    request: Request,
    current_admin: Admin = Depends(check_permission("analytics:view")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, "analytics:summary", current_admin.AdminID)
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_analytics_summary(db)
    set_to_cache(cache_key, result, CACHE_TTL_SHORT)  # 5 min TTL for analytics
    return result


@router.get("/admins", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_all_admins(
    request: Request,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    username: Optional[str] = Query(None),
    email: Optional[str] = Query(None),
    role: Optional[str] = Query(None),
    sort_by: Optional[AdminSortBy] = Query(None),
    order: Optional[AdminOrder] = Query(None),
    current_admin: Admin = Depends(check_permission("admin:view_all")),
    db: Session = Depends(get_db),
):
    params = {
        "page": page,
        "per_page": per_page,
        "username": username,
        "email": email,
        "role": role,
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(request, "admins", current_admin.AdminID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_all_admins(
        db,
        current_admin_id=current_admin.AdminID,
        page=page,
        per_page=per_page,
        username=username,
        email=email,
        role=role,
        sort_by=sort_by,
        order=order,
    )
    set_to_cache(
        cache_key, result.model_dump(), CACHE_TTL_MEDIUM
    )  # 1 hr TTL for admin list
    return result


@router.put("/users/toggle_user_status/{user_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def toggle_user_status(
    request: Request,
    user_id: int,
    current_admin: Admin = Depends(check_permission("user:approve")),
    db: Session = Depends(get_db),
):
    result = toggle_user_active_status(user_id, current_admin.AdminID, db)
    invalidate_cache(f"users:user:{user_id}")  # Invalidate user-specific cache
    invalidate_cache("users:")  # Invalidate user list cache
    return result


@router.get("/users", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_users(
    request: Request,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    username: Optional[str] = None,
    email: Optional[str] = None,
    isactive: Optional[bool] = None,
    account_type: Optional[str] = None,
    balance_min: Optional[float] = None,
    balance_max: Optional[float] = None,
    sort_by: Optional[SortBy] = None,
    order: Optional[Order] = None,
    current_admin: Admin = Depends(check_permission("user:view_all")),
    db: Session = Depends(get_db),
):
    params = {
        "page": page,
        "per_page": per_page,
        "username": username,
        "email": email,
        "isactive": isactive,
        "account_type": account_type,
        "balance_min": balance_min,
        "balance_max": balance_max,
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(request, "users", current_admin.AdminID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_all_users(
        page,
        per_page,
        username,
        email,
        isactive,
        account_type,
        balance_min,
        balance_max,
        sort_by,
        order,
        db,
    )
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL for user list
    return result


@router.post("/users/{user_id}/deposits", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
async def create_user_deposit(
    request: Request,
    user_id: int,
    deposit: DepositCreate,
    background_tasks: BackgroundTasks,
    current_admin: Admin = Depends(check_permission("deposit:manage")),
    db: Session = Depends(get_db),
):
    result = await create_deposit(
        user_id=user_id,
        admin_id=current_admin.AdminID,
        deposit=deposit,
        db=db,
        background_tasks=background_tasks,
    )
    invalidate_cache(f"users:user:{user_id}")  # Invalidate user-specific cache
    invalidate_cache("analytics:summary")  # Invalidate analytics cache
    return result


@router.get("/loans", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_all_loans(
    request: Request,
    current_admin: Admin = Depends(check_permission("loan:view_all")),
    db: Session = Depends(get_db),
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    loan_status: Optional[str] = Query(None),
    user_id: Optional[int] = Query(None),
    loan_type_id: Optional[int] = Query(None),
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    sort_by: Optional[str] = Query("CreatedAt"),
    order: Optional[str] = Query("desc"),
):
    params = {
        "page": page,
        "per_page": per_page,
        "loan_status": loan_status,
        "user_id": user_id,
        "loan_type_id": loan_type_id,
        "start_date": str(start_date),
        "end_date": str(end_date),
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(request, "loans", current_admin.AdminID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_all_loans(
        db,
        page,
        per_page,
        loan_status,
        user_id,
        loan_type_id,
        start_date,
        end_date,
        sort_by,
        order,
    )
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)  # 1 hr TTL for loans
    return result


@router.put("/loans/{loan_id}/approve", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
async def approve_loan(
    request: Request,
    loan_id: int,
    background_tasks: BackgroundTasks,
    current_admin: Admin = Depends(check_permission("loan:approve")),
    db: Session = Depends(get_db),
):
    result = await approve_loan(loan_id, current_admin, db, background_tasks)
    invalidate_cache("loans:")
    invalidate_cache("analytics:summary")
    return result


@router.put("/users/{user_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_user_route(
    request: Request,
    user_id: int,
    user_update: UserUpdate,
    current_admin: Admin = Depends(check_permission("user:update")),
    db: Session = Depends(get_db),
):
    result = update_user(user_id, user_update, db)
    invalidate_cache(f"users:user:{user_id}")
    invalidate_cache("users:")
    return result


@router.delete("/users/{user_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def delete_user_route(
    request: Request,
    user_id: int,
    current_admin: Admin = Depends(check_permission("user:delete")),
    db: Session = Depends(get_db),
):
    result = delete_user(user_id, db)
    invalidate_cache(f"users:user:{user_id}")
    invalidate_cache("users:")
    return result


@router.get("/transactions", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_all_transactions(
    request: Request,
    current_admin: Admin = Depends(check_permission("transaction:view_all")),
    db: Session = Depends(get_db),
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    transaction_type: Optional[str] = Query(None),
    transaction_status: Optional[str] = Query(None),
    user_id: Optional[int] = Query(None),
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    sort_by: Optional[str] = Query("Timestamp"),
    order: Optional[str] = Query("desc"),
):
    params = {
        "page": page,
        "per_page": per_page,
        "transaction_type": transaction_type,
        "transaction_status": transaction_status,
        "user_id": user_id,
        "start_date": str(start_date),
        "end_date": str(end_date),
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(request, "transactions", current_admin.AdminID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_all_transactions(
        db,
        page,
        per_page,
        transaction_type,
        transaction_status,
        user_id,
        start_date,
        end_date,
        sort_by,
        order,
    )
    set_to_cache(
        cache_key, result.model_dump(), CACHE_TTL_SHORT
    )  # 5 min TTL for transactions
    return result


@router.get("/cards", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_all_cards_route(
    request: Request,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    user_id: Optional[int] = Query(None),
    current_admin: Admin = Depends(check_permission("card:view_all")),
    db: Session = Depends(get_db),
):
    params = {"page": page, "per_page": per_page, "user_id": user_id}
    cache_key = get_cache_key(request, "cards", current_admin.AdminID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = list_all_cards(db, page, per_page, user_id)
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)  # 1 hr TTL for cards
    return result


@router.put("/cards/{card_id}/block", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def block_card_route(
    request: Request,
    card_id: int,
    current_admin: Admin = Depends(check_permission("card:manage")),
    db: Session = Depends(get_db),
):
    result = block_card(card_id, db)
    invalidate_cache("cards:")
    return result


@router.put("/cards/{card_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_card_admin_route(
    request: Request,
    card_id: int,
    card_update: CardUpdate,
    current_admin: Admin = Depends(check_permission("card:manage")),
    db: Session = Depends(get_db),
):
    result = update_card_admin(card_id, card_update, db)
    invalidate_cache("cards:")
    return result


@router.get("/transactions/export")
@limiter.limit(os.getenv("RATE_LIMIT_EXPORT", "5/hour"))
def export_transactions_route(
    request: Request,
    user_id: Optional[int] = Query(None),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    transaction_status: Optional[str] = Query(None),
    transaction_type: Optional[str] = Query(None),
    current_admin: Admin = Depends(check_permission("transactions:export")),
    db: Session = Depends(get_db),
):
    return export_transactions(
        db, user_id, start_date, end_date, transaction_status, transaction_type
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/routes/atm.py
<DOCUMENT>
# app/routes/atm.py
from fastapi import APIRouter, Depends, Request, BackgroundTasks
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas.withdrawal_schema import WithdrawalCreate
from app.controllers.withdrawals.atm import create_withdrawal
from app.core.schemas import BaseResponse
from app.core.rate_limiter import limiter
import os

router = APIRouter()


@router.post("/withdraw", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
async def create_withdrawal_route(
    request: Request,
    withdrawal: WithdrawalCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    return await create_withdrawal(withdrawal, db, background_tasks)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/routes/rbac.py
<DOCUMENT>
# app/routes/rbac.py
from fastapi import APIRouter, Depends, status, Request
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.core.rbac import check_permission
from app.core.schemas import BaseResponse
from app.models.admin import Admin
from app.schemas.rbac_schema import (
    PermissionUpdate,
    RoleCreate,
    PermissionCreate,
    RolePermissionCreate,
    RolePermissionRemove,
    RoleUpdate,
)
from app.controllers.rbac_controller import (
    create_role,
    delete_permission,
    delete_role,
    list_role_permissions,
    list_roles,
    create_permission,
    list_permissions,
    assign_permissions_to_role,
    remove_permissions_from_role,
    update_permission,
    update_role,
)
from typing import Union, List
from app.core.rate_limiter import (
    limiter,
    CACHE_TTL_LONG,
    get_cache_key,
    get_from_cache,
    set_to_cache,
    invalidate_cache,
)
import os

router = APIRouter()


@router.post("/roles", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def create_role_route(
    request: Request,
    role_input: Union[RoleCreate, List[RoleCreate]],
    current_admin: Admin = Depends(check_permission("rbac:manage_roles")),
    db: Session = Depends(get_db),
):
    result = create_role(role_input, db)
    invalidate_cache("roles:")
    return result


@router.get("/roles", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_roles_route(
    request: Request,
    current_admin: Admin = Depends(check_permission("rbac:view_roles")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, "roles")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = list_roles(db)
    set_to_cache(cache_key, result, CACHE_TTL_LONG)  # 24 hr TTL
    return result


@router.post("/permissions", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def create_permission_route(
    request: Request,
    perm_input: Union[PermissionCreate, List[PermissionCreate]],
    current_admin: Admin = Depends(check_permission("rbac:manage_permissions")),
    db: Session = Depends(get_db),
):
    result = create_permission(perm_input, db)
    invalidate_cache("permissions:")
    return result


@router.get("/permissions", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_permissions_route(
    request: Request,
    current_admin: Admin = Depends(check_permission("rbac:view_permissions")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, "permissions")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = list_permissions(db)
    set_to_cache(cache_key, result, CACHE_TTL_LONG)  # 24 hr TTL
    return result


@router.post("/role_permissions", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def assign_permissions_to_role_route(
    request: Request,
    rp: RolePermissionCreate,
    current_admin: Admin = Depends(check_permission("rbac:manage_role_permissions")),
    db: Session = Depends(get_db),
):
    result = assign_permissions_to_role(rp, db)
    invalidate_cache(f"role_permissions:{rp.RoleID}")
    return result


@router.delete("/role_permissions", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def remove_permissions_from_role_route(
    request: Request,
    rp_remove: RolePermissionRemove,
    current_admin: Admin = Depends(check_permission("rbac:manage_role_permissions")),
    db: Session = Depends(get_db),
):
    result = remove_permissions_from_role(rp_remove, db)
    invalidate_cache(f"role_permissions:{rp_remove.RoleID}")
    return result


@router.get("/roles/{role_id}/permissions", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_role_permissions_route(
    request: Request,
    role_id: int,
    current_admin: Admin = Depends(check_permission("rbac:view_roles")),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"role_permissions:{role_id}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = list_role_permissions(role_id, db)
    set_to_cache(cache_key, result, CACHE_TTL_LONG)  # 24 hr TTL
    return result


@router.put("/roles/{role_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_role_route(
    request: Request,
    role_id: int,
    role_update: RoleUpdate,
    current_admin: Admin = Depends(check_permission("rbac:manage_roles")),
    db: Session = Depends(get_db),
):
    result = update_role(role_id, role_update, db)
    invalidate_cache("roles:")
    invalidate_cache(f"role_permissions:{role_id}")
    return result


@router.delete("/roles/{role_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def delete_role_route(
    request: Request,
    role_id: int,
    current_admin: Admin = Depends(check_permission("rbac:manage_roles")),
    db: Session = Depends(get_db),
):
    result = delete_role(role_id, db)
    invalidate_cache("roles:")
    invalidate_cache(f"role_permissions:{role_id}")
    return result


@router.put("/permissions/{permission_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def update_permission_route(
    request: Request,
    permission_id: int,
    perm_update: PermissionUpdate,
    current_admin: Admin = Depends(check_permission("rbac:manage_permissions")),
    db: Session = Depends(get_db),
):
    result = update_permission(permission_id, perm_update, db)
    invalidate_cache("permissions:")
    return result


@router.delete("/permissions/{permission_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_ADMIN_CRITICAL", "10/minute"))
def delete_permission_route(
    request: Request,
    permission_id: int,
    current_admin: Admin = Depends(check_permission("rbac:manage_permissions")),
    db: Session = Depends(get_db),
):
    result = delete_permission(permission_id, db)
    invalidate_cache("permissions:")
    return result
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/routes/users.py
<DOCUMENT>
# app/routes/users.py
from datetime import date, datetime
from typing import Optional
from fastapi import APIRouter, Depends, Query, Request, BackgroundTasks
from sqlalchemy.orm import Session

# Controllers
from app.controllers.cards.users import (
    create_card,
    delete_card,
    list_cards,
    update_card,
)
from app.controllers.transactions.users import get_user_transactions
from app.controllers.transfers.users import create_transfer
from app.controllers.user_controller import (
    export_user_transactions,
    register_user,
    login_user,
    update_current_user,
    update_user_password,
    get_user_analytics_summary,
    get_user_profile,
)
from app.controllers.loans.users import (
    apply_loan,
    get_loan_types,
    make_loan_payment,
    get_user_loans,
    get_loan_payments,
)

# Schemas
from app.schemas.card_schema import CardCreate, CardUpdate
from app.schemas.transfer_schema import TransferCreate
from app.schemas.user_schema import (
    PaginationParams,
    UserCreate,
    UserLogin,
    UserPasswordUpdate,
    UserUpdate,
)
from app.schemas.loan_schema import LoanApply, LoanPaymentCreate

# Models
from app.models.user import User

# Core
from app.core.database import get_db
from app.core.schemas import BaseResponse, PaginatedResponse
from app.core.auth import get_current_user, refresh_token
from app.core.rate_limiter import (
    limiter,
    get_redis_client,
    CACHE_TTL_SHORT,
    CACHE_TTL_MEDIUM,
    CACHE_TTL_LONG,
    get_cache_key,
    get_from_cache,
    set_to_cache,
    invalidate_cache,
)
import json
import os

router = APIRouter()


@router.post("/register", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def register(request: Request, user: UserCreate, db: Session = Depends(get_db)):
    return register_user(user, db)


@router.post("/login", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_LOGIN", "5/minute"))
def login(request: Request, credentials: UserLogin, db: Session = Depends(get_db)):
    return login_user(credentials, db)


@router.post("/refresh", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def refresh(request: Request, token: str, db: Session = Depends(get_db)):
    return refresh_token(token, db, User, "User", "UserID")


@router.get("/analytics/summary", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_user_analytics_summary_route(
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, "user_analytics:summary", current_user.UserID)
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_user_analytics_summary(current_user.UserID, db)
    set_to_cache(cache_key, result, CACHE_TTL_SHORT)  # 5 min TTL
    return result


@router.get("/transactions", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_user_transactions(
    request: Request,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    params: PaginationParams = Depends(),
    transaction_type: Optional[str] = Query(None),
    transaction_status: Optional[str] = Query(None),
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    sort_by: Optional[str] = Query("Timestamp"),
    order: Optional[str] = Query("desc"),
):
    query_params = {
        "page": params.page,
        "per_page": params.per_page,
        "transaction_type": transaction_type,
        "transaction_status": transaction_status,
        "start_date": str(start_date),
        "end_date": str(end_date),
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(
        request, "user_transactions", current_user.UserID, query_params
    )
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_user_transactions(
        current_user.UserID,
        db,
        params.page,
        params.per_page,
        transaction_type,
        transaction_status,
        start_date,
        end_date,
        sort_by,
        order,
    )
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_SHORT)  # 5 min TTL
    return result


@router.post("/transfer", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
async def create_transfer_route(
    request: Request,
    transfer: TransferCreate,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = await create_transfer(current_user.UserID, transfer, db, background_tasks)
    invalidate_cache(f"user_analytics:summary:user:{current_user.UserID}")
    invalidate_cache(f"user_transactions:user:{current_user.UserID}")
    return result


@router.get("/cards", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_cards_route(
    request: Request,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    sort_by: str = Query(
        "CardID", description="Sort by: CardID, ExpirationDate, Status, CardNumber"
    ),
    order: str = Query("asc", regex="^(asc|desc)$", description="Order: asc or desc"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    params = {"page": page, "per_page": per_page, "sort_by": sort_by, "order": order}
    cache_key = get_cache_key(request, "user_cards", current_user.UserID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = list_cards(current_user.UserID, db, page, per_page, sort_by, order)
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)
    return result


@router.post("/cards", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def create_card_route(
    request: Request,
    card: CardCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = create_card(current_user.UserID, card, db)
    invalidate_cache(f"user_cards:user:{current_user.UserID}")
    return result


@router.put("/cards/{card_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def update_card_route(
    request: Request,
    card_id: int,
    card_update: CardUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = update_card(current_user.UserID, card_id, card_update, db)
    invalidate_cache(f"user_cards:user:{current_user.UserID}")
    return result


@router.delete("/cards/{card_id}", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def delete_card_route(
    request: Request,
    card_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = delete_card(current_user.UserID, card_id, db)
    invalidate_cache(f"user_cards:user:{current_user.UserID}")
    return result


@router.post("/loans/apply", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def apply_for_loan(
    request: Request,
    loan: LoanApply,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = apply_loan(current_user.UserID, loan, db)
    invalidate_cache(f"user_loans:user:{current_user.UserID}")
    invalidate_cache(f"user_analytics:summary:user:{current_user.UserID}")
    return result


@router.get("/loans/types", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_loan_types(
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    cache_key = get_cache_key(request, "loan_types")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_loan_types(db)
    set_to_cache(cache_key, result, CACHE_TTL_LONG)  # 24 hr TTL for static data
    return result


@router.post("/loans/payments", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def record_loan_payment(
    request: Request,
    payment: LoanPaymentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = make_loan_payment(current_user.UserID, payment, db)
    invalidate_cache(f"user_loans:user:{current_user.UserID}")
    invalidate_cache(f"user_analytics:summary:user:{current_user.UserID}")
    return result


@router.get("/loans", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_user_loans(
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    status: Optional[str] = Query(None),
    sort_by: Optional[str] = Query("CreatedAt"),
    order: Optional[str] = Query("desc"),
):
    params = {
        "page": page,
        "per_page": per_page,
        "status": status,
        "sort_by": sort_by,
        "order": order,
    }
    cache_key = get_cache_key(request, "user_loans", current_user.UserID, params)
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_user_loans(
        current_user.UserID, db, page, per_page, status, sort_by, order
    )
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.get("/loans/{loan_id}/payments", response_model=PaginatedResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def list_loan_payments(
    request: Request,
    loan_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
):
    params = {"page": page, "per_page": per_page}
    cache_key = get_cache_key(
        request, f"user_loan_payments:{loan_id}", current_user.UserID, params
    )
    cached = get_from_cache(cache_key)
    if cached:
        return PaginatedResponse(**cached)
    result = get_loan_payments(current_user.UserID, loan_id, db, page, per_page)
    set_to_cache(cache_key, result.model_dump(), CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.get("/me", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def get_current_user_route(
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    cache_key = get_cache_key(request, f"user:{current_user.UserID}")
    cached = get_from_cache(cache_key)
    if cached:
        return BaseResponse(**cached)
    result = get_user_profile(current_user.UserID, db)
    set_to_cache(cache_key, result, CACHE_TTL_MEDIUM)  # 1 hr TTL
    return result


@router.put("/me", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def update_current_user_route(
    request: Request,
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    result = update_current_user(current_user.UserID, user_update, db)
    invalidate_cache(f"user_analytics:summary:user:{current_user.UserID}")
    return result


@router.put("/me/password", response_model=BaseResponse)
@limiter.limit(os.getenv("RATE_LIMIT_USER_DEFAULT", "100/hour"))
def update_user_password_route(
    request: Request,
    password_update: UserPasswordUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    return update_user_password(current_user.UserID, password_update, db)


@router.get("/transactions/export")
@limiter.limit(os.getenv("RATE_LIMIT_EXPORT", "5/hour"))
def export_user_transactions_route(
    request: Request,
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    transaction_status: Optional[str] = Query(None),
    transaction_type: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    return export_user_transactions(
        current_user.UserID,
        db,
        start_date,
        end_date,
        transaction_status,
        transaction_type,
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/routes/websocket.py
<DOCUMENT>
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query, Depends
from fastapi.websockets import WebSocketState
from app.core.websocket_manager import ConnectionManager
from app.core.auth import jwt, SECRET_KEY, ALGORITHM
from app.core.database import get_db
from sqlalchemy.orm import Session

router = APIRouter()
manager = ConnectionManager()


async def get_token_payload(token: str, db: Session):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except Exception as e:
        return None


@router.websocket("/ws/user")
async def user_websocket(
    websocket: WebSocket, token: str = Query(...), db: Session = Depends(get_db)
):
    user_id = None
    try:
        # Verify token
        payload = await get_token_payload(token, db)
        if not payload:
            await websocket.send_text("Invalid or expired token")
            await websocket.close(code=4001)
            return

        user_id = int(payload.get("sub"))
        print(f"User {user_id} connecting to WebSocket")

        # Connect to WebSocket
        entity_id = await manager.connect(websocket, token, "user")
        if not entity_id:
            await websocket.close(code=4002)
            return

        print(f"User {user_id} connected successfully")

        try:
            while True:
                data = await websocket.receive_text()
                print(f"Received message from user {user_id}: {data}")
        except WebSocketDisconnect:
            print(f"User {user_id} disconnected")
            if user_id:
                await manager.disconnect(websocket, user_id, "user")
        except Exception as e:
            print(f"Error in user websocket: {str(e)}")
            if user_id:
                await manager.disconnect(websocket, user_id, "user")
            if websocket.client_state != WebSocketState.DISCONNECTED:
                await websocket.close(code=4000)
    except Exception as e:
        print(f"WebSocket connection error: {str(e)}")
        if websocket.client_state != WebSocketState.DISCONNECTED:
            await websocket.close(code=4000)


@router.websocket("/ws/admin")
async def admin_websocket(
    websocket: WebSocket, token: str = Query(...), db: Session = Depends(get_db)
):
    try:
        # Verify token
        payload = await get_token_payload(token, db)
        if not payload:
            print("Invalid admin token")
            await websocket.close(code=4001)
            return

        admin_id = int(payload.get("sub"))
        print(f"Admin {admin_id} connecting to WebSocket")

        # Connect to WebSocket
        entity_id = await manager.connect(websocket, token, "admin")
        if not entity_id:
            print(f"Failed to connect admin {admin_id}")
            await websocket.close(code=4002)
            return

        print(f"Admin {admin_id} connected successfully")

        try:
            while True:
                data = await websocket.receive_text()
                print(f"Received message from admin {admin_id}: {data}")
        except WebSocketDisconnect:
            print(f"Admin {admin_id} disconnected")
            await manager.disconnect(websocket, admin_id, "admin")
        except Exception as e:
            print(f"Error in admin websocket: {str(e)}")
            await manager.disconnect(websocket, admin_id, "admin")
            await websocket.close(code=4000)
    except Exception as e:
        print(f"Admin WebSocket connection error: {str(e)}")
        if not websocket.client_state.disconnected:
            await websocket.close(code=4000)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/admin_schema.py
<DOCUMENT>
from pydantic import BaseModel, EmailStr, constr, ConfigDict
from datetime import datetime
from typing import Optional, List
from enum import Enum


class AdminCreate(BaseModel):
    Username: constr(min_length=3, max_length=50)  # type: ignore
    Email: EmailStr
    Password: constr(min_length=8, max_length=255)  # type: ignore # Enforce min 8 characters
    RoleID: int


class AdminLogin(BaseModel):
    Email: EmailStr
    Password: constr(min_length=8, max_length=255)  # type: ignore # Enforce min 8 characters


class RoleData(BaseModel):
    RoleID: int
    RoleName: str
    Description: Optional[str] = None
    model_config = ConfigDict(from_attributes=True)


class PermissionData(BaseModel):
    PermissionID: int
    PermissionName: str
    Description: Optional[str] = None
    model_config = ConfigDict(from_attributes=True)


class AdminUpdate(BaseModel):
    Username: Optional[constr(min_length=3, max_length=50)] = None  # type: ignore
    Email: Optional[EmailStr] = None
    model_config = ConfigDict(from_attributes=True)


class AdminPasswordUpdate(BaseModel):
    CurrentPassword: constr(min_length=8, max_length=255)  # type: ignore
    NewPassword: constr(min_length=8, max_length=255)  # type: ignore


class AdminResponseData(BaseModel):
    AdminID: int
    Username: str
    Email: EmailStr
    RoleID: int
    CreatedAt: datetime
    LastLogin: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)


class AdminLoginResponseData(BaseModel):
    AdminID: int
    Username: str
    Email: EmailStr
    Role: RoleData
    Permissions: List[PermissionData]
    LastLogin: Optional[str] = None
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    model_config = ConfigDict(from_attributes=True)


class AdminSortBy(str, Enum):
    admin_id = "AdminID"
    username = "Username"
    email = "Email"
    role = "RoleID"
    created_at = "CreatedAt"
    last_login = "LastLogin"


class AdminOrder(str, Enum):
    asc = "asc"
    desc = "desc"
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/card_schema.py
<DOCUMENT>
from pydantic import BaseModel, ConfigDict, constr, validator
from datetime import date, datetime
from typing import Optional


class CardCreate(BaseModel):
    CardNumber: constr(pattern=r"^\d{16}$")  # type: ignore
    Pin: constr(min_length=4, max_length=4, pattern=r"^\d{4}$")  # type: ignore
    ExpirationDate: date


class CardUpdate(BaseModel):
    Pin: Optional[constr(min_length=4, max_length=4, pattern=r"^\d{4}$")] = None  # type: ignore
    Status: Optional[str] = None  # "Active", "Inactive", "Blocked"

    @validator("Status")
    def validate_status(cls, v):
        if v and v not in ["Active", "Inactive", "Blocked"]:
            raise ValueError("Status must be 'Active', 'Inactive', or 'Blocked'")
        return v


class CardResponse(BaseModel):
    CardID: int
    UserID: int
    CardNumber: str
    ExpirationDate: date
    Status: str
    CreatedAt: datetime
    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={
            datetime: lambda v: v.isoformat(),
            date: lambda v: v.isoformat(),  # Handle date objects
        },
    )
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/deposit_schema.py
<DOCUMENT>
from datetime import datetime
from pydantic import BaseModel, ConfigDict
from decimal import Decimal
from typing import Optional


class DepositCreate(BaseModel):
    Amount: Decimal
    Description: Optional[str] = None


class DepositResponse(BaseModel):
    DepositID: int
    UserID: int
    AdminID: int
    Amount: float
    ReferenceNumber: str
    Status: str
    Description: Optional[str]
    Timestamp: datetime
    model_config = ConfigDict(from_attributes=True)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/loan_schema.py
<DOCUMENT>
from pydantic import BaseModel, ConfigDict, Field
from datetime import date, datetime
from decimal import Decimal
from typing import Optional


class LoanApply(BaseModel):
    LoanTypeID: int
    LoanAmount: Decimal = Field(gt=0)
    LoanDurationMonths: int
    DueDate: date


class LoanPaymentCreate(BaseModel):
    LoanID: int
    PaymentAmount: Decimal


class LoanResponse(BaseModel):
    LoanID: int
    LoanTypeName: str
    LoanAmount: Decimal
    InterestRate: Decimal
    LoanDurationMonths: int
    MonthlyInstallment: Decimal
    DueDate: date
    LoanStatus: str
    CreatedAt: Optional[date]
    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={
            datetime: lambda v: v.isoformat(),
            date: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        },
    )


class LoanPaymentResponse(BaseModel):
    PaymentID: int
    LoanID: int
    PaymentAmount: Decimal
    PaymentDate: date
    LateFee: Decimal
    TotalAmountPaid: Decimal
    model_config = ConfigDict(from_attributes=True)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/rbac_schema.py
<DOCUMENT>
from pydantic import BaseModel
from typing import Optional, Union, List


class RoleCreate(BaseModel):
    RoleName: str
    Description: str | None = None


class PermissionCreate(BaseModel):
    PermissionName: str
    Description: str | None = None


class RolePermissionCreate(BaseModel):
    RoleID: int
    PermissionID: Union[int, List[int]]


class RoleUpdate(BaseModel):
    RoleName: Optional[str] = None
    Description: Optional[str] = None


class PermissionUpdate(BaseModel):
    PermissionName: Optional[str] = None
    Description: Optional[str] = None


class RolePermissionRemove(BaseModel):
    RoleID: int
    PermissionID: Union[
        int, List[int]
    ]  # Supports removing single or multiple permissions
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/transfer_schema.py
<DOCUMENT>
from datetime import datetime
from pydantic import BaseModel, ConfigDict
from decimal import Decimal
from typing import Optional


class TransferCreate(BaseModel):
    ReceiverID: int
    Amount: Decimal
    Description: Optional[str] = None


class TransferResponse(BaseModel):
    TransferID: int
    SenderID: int
    ReceiverID: int
    Amount: float
    ReferenceNumber: str
    Status: str
    Description: Optional[str]
    Timestamp: datetime
    model_config = ConfigDict(from_attributes=True)
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/user_schema.py
<DOCUMENT>
from pydantic import BaseModel, EmailStr, constr, validator, ConfigDict
from datetime import date, datetime
from typing import Optional
from enum import Enum

from decimal import Decimal


class UserCreate(BaseModel):
    Username: constr(min_length=3, max_length=50)  # type: ignore
    FirstName: constr(max_length=50) = ""  # type: ignore
    LastName: constr(max_length=50) = ""  # type: ignore
    StreetAddress: Optional[constr(max_length=255)] = None  # type: ignore
    City: Optional[constr(max_length=50)] = None  # type: ignore
    State: Optional[constr(max_length=50)] = None  # type: ignore
    Country: Optional[constr(max_length=50)] = None  # type: ignore
    PostalCode: Optional[constr(max_length=20)] = None  # type: ignore
    PhoneNumber: Optional[constr(max_length=20)] = None  # type: ignore
    CNIC: constr(pattern=r"^\d{5}-\d{7}-\d{1}$")  # type: ignore
    Email: EmailStr
    Password: constr(min_length=8, max_length=255)  # type: ignore
    IsActive: bool = False
    AccountType: str
    DateOfBirth: date

    @validator("AccountType")
    def validate_account_type(cls, v):
        if v not in ("Savings", "Current"):
            raise ValueError("AccountType must be either 'Savings' or 'Current'")
        return v

    @validator("CNIC")
    def validate_cnic_format(cls, v):
        if not (v[5] == "-" and v[13] == "-" and len(v) == 15):
            raise ValueError("CNIC must be in format XXXXX-XXXXXXX-X")
        return v


class UserUpdate(BaseModel):
    Username: Optional[constr(min_length=3, max_length=50)] = None  # type: ignore
    FirstName: Optional[constr(max_length=50)] = None  # type: ignore
    LastName: Optional[constr(max_length=50)] = None  # type: ignore
    StreetAddress: Optional[constr(max_length=255)] = None  # type: ignore
    City: Optional[constr(max_length=50)] = None  # type: ignore
    State: Optional[constr(max_length=50)] = None  # type: ignore
    Country: Optional[constr(max_length=50)] = None  # type: ignore
    PostalCode: Optional[constr(max_length=20)] = None  # type: ignore
    PhoneNumber: Optional[constr(max_length=20)] = None  # type: ignore
    Password: Optional[constr(min_length=8, max_length=255)] = None  # type: ignore # Added for admin updates
    Email: Optional[EmailStr] = None
    IsActive: Optional[bool] = None  # Admin-only field, added for flexibility
    model_config = ConfigDict(from_attributes=True)


# Dedicated schema for user password update
class UserPasswordUpdate(BaseModel):
    CurrentPassword: constr(min_length=8, max_length=255)  # type: ignore
    NewPassword: constr(min_length=8, max_length=255)  # type: ignore


class UserLogin(BaseModel):
    login_id: str  # Can be either email or username
    Password: constr(min_length=8, max_length=255)  # type: ignore

    @validator("login_id")
    def validate_login_id(cls, v):
        if not v:
            raise ValueError("Login ID cannot be empty")
        return v


class UserResponseData(BaseModel):
    UserID: int
    Username: str
    FirstName: str
    LastName: str
    StreetAddress: Optional[str] = None
    City: Optional[str] = None
    State: Optional[str] = None
    Country: Optional[str] = None
    PostalCode: Optional[str] = None
    PhoneNumber: Optional[str] = None
    CNIC: str
    Email: str
    AccountType: str
    Balance: float
    IsActive: bool
    DateOfBirth: date  # Accept date object
    CreatedAt: datetime  # Accept datetime object
    LastLogin: Optional[datetime] = None  # Accept datetime object or None
    access_token: str = ""
    refresh_token: str = ""
    token_type: str = "bearer"

    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={
            datetime: lambda v: v.isoformat() if v else None,
            date: lambda v: v.isoformat() if v else None,
            Decimal: lambda v: float(v),
        },
    )


class LoginResponseData(BaseModel):
    UserID: int
    Username: str
    Email: EmailStr
    AccountType: str
    last_login: Optional[str] = None
    model_config = ConfigDict(from_attributes=True)


class SortBy(str, Enum):
    user_id = "user_id"
    username = "username"
    email = "email"
    balance = "balance"
    created_at = "created_at"
    last_login = "last_login"


class Order(str, Enum):
    asc = "asc"
    desc = "desc"


class PaginationParams(BaseModel):
    page: int = 1  # Default to page 1
    per_page: int = 10  # Default to 10 items per page
</DOCUMENT>

g:/Ahad/Python/AUT Bank/app/schemas/withdrawal_schema.py
<DOCUMENT>
from datetime import datetime
from pydantic import BaseModel, ConfigDict, constr
from decimal import Decimal
from typing import Optional


class WithdrawalCreate(BaseModel):
    CardNumber: constr(min_length=16, max_length=16, pattern=r"^\d{16}$")  # type: ignore
    Pin: constr(min_length=4, max_length=4, pattern=r"^\d{4}$")  # type: ignore
    Amount: Decimal


class WithdrawalResponse(BaseModel):
    WithdrawalID: int
    UserID: int
    CardID: int
    Amount: float
    ReferenceNumber: str
    Status: str
    Description: Optional[str]
    Timestamp: datetime
    model_config = ConfigDict(from_attributes=True)
</DOCUMENT>

